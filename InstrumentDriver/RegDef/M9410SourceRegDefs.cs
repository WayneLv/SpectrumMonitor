using System;
using InstrumentDriver.Core;
using InstrumentDriver.Core.Register;
using InstrumentDriver.Core.Interfaces;
using InstrumentDriver.Core.Utility;

namespace InstrumentDriver.NewInstrument
{

	// DO NOT EDIT THIS FILE.
	// This file was generated on 2020/1/19 20:48:46 from C:\TEMP\M9410SourceRegDefs.xlsx
	// by D:\Programs\MyRegisterFileTool\RegisterFileTool\bin\Debug\MyRegisterFileTool.exe version 1.5.5.0


	#region RegisterSets
	public class SourceRegisterSet : AbstractRegisterSet
	{

		#region Base Address(es) / Group Offset(s)

		// These are the base addresses (group offsets) defined by the register spreadsheet.
		// The client code will normally instantiate an instance of the register set for each.
		[System.Reflection.Obfuscation( Exclude = true )]
		public enum BaseAddress
		{
			Source0 = 0x0,
		}

		#endregion Base Address(es)

		#region  Register enums

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SourceRegister
		{
			RFCntrl_path, // 0x0010 
			RFCntrl_Port, // 0x0014 
			LOCntrl, // 0x0018 
			IQCntrl, // 0x001c 
			PowerCntrl, // 0x0020 
			RFAtten, // 0x0024 
			TempSensorCntrl, // 0x0028 Source temperature sensor enable
			AbusRegister, // 0x002c 
			RFUtility, // 0x0094 
			RfStatus, // 0x0004 
			ChipID_L, // 0x0030 
			ChipID_H, // 0x0034 
			RfFpgaVersion, // 0x0008 Reversion
			RfFpgaSoftReset, // 0x000c 
		}

		/// <summary>
		/// Register offset from original register definition (excludes 'Base').
		/// </summary>
		/// <remarks>
		/// The actual/runtime register offset is affected by parameters passed to the
		/// register factory and may not match the values defined here.
		/// </remarks>
		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SourceRegisterOffsets
		{
			RFCntrl_path = 0x0010, // 
			RFCntrl_Port = 0x0014, // 
			LOCntrl = 0x0018, // 
			IQCntrl = 0x001c, // 
			PowerCntrl = 0x0020, // 
			RFAtten = 0x0024, // 
			TempSensorCntrl = 0x0028, // Source temperature sensor enable
			AbusRegister = 0x002c, // 
			RFUtility = 0x0094, // 
			RfStatus = 0x0004, // 
			ChipID_L = 0x0030, // 
			ChipID_H = 0x0034, // 
			RfFpgaVersion = 0x0008, // Reversion
			RfFpgaSoftReset = 0x000c, // 
		}

		#endregion  Register enums

		#region  Register bitfield enums

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RFCntrl_pathBF
		{
			Path_Selected_2,     // Bits  0- 1 		 
			RF_Blanking,         // Bit   2 		 
			Path_Selected_1,     // Bits  3- 6 		 
			Band_Selected,       // Bit   7 		 
			Low_Band_Enable,     // Bit   8 		 
			RF_Path_Filter_Array, // Bits  9-24 		 
			Pre_HPF_Filter,      // Bits 25-28 		 
			Lowband_amp1,        // Bit  29 		 
			Lowband_amp2,        // Bit  30 		 
			U89,                 // Bits  9-10 		 
			U40,                 // Bits 11-12 		 
			U91,                 // Bits 13-14 		 
			U42,                 // Bits 15-16 		 
			U39,                 // Bits 17-18 		 
			U92,                 // Bits 19-20 		 
			U44,                 // Bits 21-22 		 
			U90,                 // Bits 23-24 		 
			U35,                 // Bits 25-26 		 
			U36,                 // Bits 27-28 		 
			U17,                 // Bit   3 		 
			U16,                 // Bit   4 		 
			U19,                 // Bit   5 		 
			U18,                 // Bit   6 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RFCntrl_PortBF
		{
			Port_Selected,       // Bits  0- 1 		 
			TX_Port_Selected,    // Bits  2- 8 		 
			TX_Port_Output_Enable, // Bit   9 		 
			HD_Port_Selected,    // Bits 10-13 		 
			Rx_Align_Path,       // Bits 14-15 		 
			Align_Path_Enable,   // Bits 16-18 		 
			HD_Port_Output_Enable, // Bit  19 		 
			HD_Port_AMP_Enable,  // Bit  20 		 
			U5,                  // Bit  16 		 
			U6,                  // Bit  17 		 
			U7,                  // Bit  18 		 
			U33,                 // Bits  2- 3 		 
			U34,                 // Bits  7- 8 		 
			U71,                 // Bit   4 		 
			U70,                 // Bit   5 		 
			U98_H637A,           // Bit   6 		 
			U112,                // Bits 10-11 		 
			U113,                // Bits 12-13 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum LOCntrlBF
		{
			LO_Level_Adjustments, // Bits  3- 6 		 
			LO_Filter_Selection, // Bits  7-10 		 
			Reserved,            // Bits 11-12 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum IQCntrlBF
		{
			IQ_Path_Select,      // Bits  0- 1 		 
			Reserved,            // Bits  2- 3 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PowerCntrlBF
		{
			P5p4V_EN_H,          // Bit   0 		 
			N3p4V_EN_H,          // Bit   1 		 
			P3p4V_EN_H,          // Bit   2 		 
			N2p5V_EN_H,          // Bit   3 		 
			P2p5V_EN_H,          // Bit   4 		 
			P3p3_H637A_EN_H,     // Bit   5 		 
			P13p62V_EN_H,        // Bit   6 		 
			N14V_EN_H,           // Bit   7 		 
			P14V_EN_H,           // Bit   8 		 
			N7p5V_EN_H,          // Bit   9 		 
			P7p8V_EN_H,          // Bit  10 		 
			N14V_RFOUT_EN_H,     // Bit  11 		 
			P14V_RFOUT_EN_H,     // Bit  12 		 
			Dac_Bias_Control,    // Bit  15 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RFAttenBF
		{
			AT1,                 // Bits  0- 4 		 
			AT2,                 // Bits  5- 9 		 
			AT3,                 // Bit  10 		 
			AT4,                 // Bits 11-14 		 
			AT5,                 // Bits 15-19 		 
			AT6,                 // Bits 20-24 		 
			AT7,                 // Bits 25-29 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TempSensorCntrlBF
		{
			TempSensorCntrl,     // Bit   0 		 Source temperature sensor enable
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum AbusRegisterBF
		{
			Bus_Addr,            // Bits  0- 3 		 
			Bus_En,              // Bit   4 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RFUtilityBF
		{
			BB_DAC_CLR_N,        // Bit   0 		 
			INCLK_EN,            // Bit   1 		 0: when 2S_USER_P1= 1, Reset DCM and ogic 1: when 2S_USER_P1= 1, Reset DCM only 0x0
			RF_BLANKING_MODE,    // Bits  2- 3 		 Rf_blanking mode set, 00: Fast mode, switch U79, U80, 01: Normal mode, switch U79, U80, U16, U19, AT3, AT4. 10,11: reserved
			FPGA_INT_EN,         // Bit   4 		 FPGA_INT line function set. 1: enable, Interrupt output, 0: disable, Trigger input
			TRIG_SRC,            // Bits  5- 6 		 Trigger source set, 00: FPGA_INT, 01: Software Trigger, 10: reserved.
			SW_TRIG,             // Bit   8 		 Software Trigger bit, 1: trigger high, 0: trigger low
			RF_BLANKING_POLARITY, // Bit   9 		 1 for positive polarity, 0 for negative polarity
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RfStatusBF
		{
			P1V2_GD,             // Bit   0 		 
			P2V5_GD,             // Bit   1 		 
			LTC2666_OverTemp,    // Bit   2 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChipID_LBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChipID_HBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RfFpgaVersionBF
		{
			Rev,                 // Bits  0- 7 		 Reversion
			Minor,               // Bits  8-15 		 Minor Version
			Major,               // Bits 16-24 		 Major Version
			BoardID,             // Bits 29-31 		 Board identify code
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RfFpgaSoftResetBF
		{
			Reset,               // Bit  31 		 
		}

		#endregion  Register bitfield enums

		#region Member Variables

		private static readonly RegDef[] mRegisterDefinitions = new[]
			{
				new RegDef((int) SourceRegister.RFCntrl_path, 0x0010, typeof(RFCntrl_pathBF), RegType.RW, 29 ),
				new RegDef((int) SourceRegister.RFCntrl_Port, 0x0014, typeof(RFCntrl_PortBF), RegType.RW, 19 ),
				new RegDef((int) SourceRegister.LOCntrl, 0x0018, typeof(LOCntrlBF), RegType.RW, 13 ),
				new RegDef((int) SourceRegister.IQCntrl, 0x001c, typeof(IQCntrlBF), RegType.RW, 4 ),
				new RegDef((int) SourceRegister.PowerCntrl, 0x0020, typeof(PowerCntrlBF), RegType.RW, 16 ),
				new RegDef((int) SourceRegister.RFAtten, 0x0024, typeof(RFAttenBF), RegType.RW, 30 ),
				new RegDef((int) SourceRegister.TempSensorCntrl, 0x0028, typeof(TempSensorCntrlBF), RegType.RW, 1 ),
				new RegDef((int) SourceRegister.AbusRegister, 0x002c, typeof(AbusRegisterBF), RegType.RW, 5 ),
				new RegDef((int) SourceRegister.RFUtility, 0x0094, typeof(RFUtilityBF), RegType.RW, 9 ),
				new RegDef((int) SourceRegister.RfStatus, 0x0004, typeof(RfStatusBF), RegType.RO, 2 ),
				new RegDef((int) SourceRegister.ChipID_L, 0x0030, typeof(ChipID_LBF), RegType.RO ),
				new RegDef((int) SourceRegister.ChipID_H, 0x0034, typeof(ChipID_HBF), RegType.RO ),
				new RegDef((int) SourceRegister.RfFpgaVersion, 0x0008, typeof(RfFpgaVersionBF), RegType.RO ),
				new RegDef((int) SourceRegister.RfFpgaSoftReset, 0x000c, typeof(RfFpgaSoftResetBF), RegType.WO, 1 ),
			};

		private static readonly BitFieldDef[] mBitFieldDefinitions = new []
			{
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.Path_Selected_2, 0, 1 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.RF_Blanking, 2 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.Path_Selected_1, 3, 6 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.Band_Selected, 7 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.Low_Band_Enable, 8 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.RF_Path_Filter_Array, 9, 24 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.Pre_HPF_Filter, 25, 28 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.Lowband_amp1, 29 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.Lowband_amp2, 30 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U89, 9, 10 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U40, 11, 12 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U91, 13, 14 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U42, 15, 16 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U39, 17, 18 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U92, 19, 20 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U44, 21, 22 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U90, 23, 24 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U35, 25, 26 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U36, 27, 28 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U17, 3 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U16, 4 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U19, 5 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_path, (int)RFCntrl_pathBF.U18, 6 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.Port_Selected, 0, 1 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.TX_Port_Selected, 2, 8 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.TX_Port_Output_Enable, 9 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.HD_Port_Selected, 10, 13 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.Rx_Align_Path, 14, 15 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.Align_Path_Enable, 16, 18 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.HD_Port_Output_Enable, 19 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.HD_Port_AMP_Enable, 20 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U5, 16 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U6, 17 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U7, 18 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U33, 2, 3 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U34, 7, 8 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U71, 4 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U70, 5 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U98_H637A, 6 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U112, 10, 11 ),
				new BitFieldDef( (int)SourceRegister.RFCntrl_Port, (int)RFCntrl_PortBF.U113, 12, 13 ),
				new BitFieldDef( (int)SourceRegister.LOCntrl, (int)LOCntrlBF.LO_Level_Adjustments, 3, 6 ),
				new BitFieldDef( (int)SourceRegister.LOCntrl, (int)LOCntrlBF.LO_Filter_Selection, 7, 10 ),
				new BitFieldDef( (int)SourceRegister.LOCntrl, (int)LOCntrlBF.Reserved, 11, 12 ),
				new BitFieldDef( (int)SourceRegister.IQCntrl, (int)IQCntrlBF.IQ_Path_Select, 0, 1 ),
				new BitFieldDef( (int)SourceRegister.IQCntrl, (int)IQCntrlBF.Reserved, 2, 3 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.P5p4V_EN_H, 0 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.N3p4V_EN_H, 1 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.P3p4V_EN_H, 2 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.N2p5V_EN_H, 3 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.P2p5V_EN_H, 4 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.P3p3_H637A_EN_H, 5 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.P13p62V_EN_H, 6 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.N14V_EN_H, 7 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.P14V_EN_H, 8 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.N7p5V_EN_H, 9 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.P7p8V_EN_H, 10 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.N14V_RFOUT_EN_H, 11 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.P14V_RFOUT_EN_H, 12 ),
				new BitFieldDef( (int)SourceRegister.PowerCntrl, (int)PowerCntrlBF.Dac_Bias_Control, 15 ),
				new BitFieldDef( (int)SourceRegister.RFAtten, (int)RFAttenBF.AT1, 0, 4 ),
				new BitFieldDef( (int)SourceRegister.RFAtten, (int)RFAttenBF.AT2, 5, 9 ),
				new BitFieldDef( (int)SourceRegister.RFAtten, (int)RFAttenBF.AT3, 10 ),
				new BitFieldDef( (int)SourceRegister.RFAtten, (int)RFAttenBF.AT4, 11, 14 ),
				new BitFieldDef( (int)SourceRegister.RFAtten, (int)RFAttenBF.AT5, 15, 19 ),
				new BitFieldDef( (int)SourceRegister.RFAtten, (int)RFAttenBF.AT6, 20, 24 ),
				new BitFieldDef( (int)SourceRegister.RFAtten, (int)RFAttenBF.AT7, 25, 29 ),
				new BitFieldDef( (int)SourceRegister.TempSensorCntrl, (int)TempSensorCntrlBF.TempSensorCntrl, 0 ),
				new BitFieldDef( (int)SourceRegister.AbusRegister, (int)AbusRegisterBF.Bus_Addr, 0, 3 ),
				new BitFieldDef( (int)SourceRegister.AbusRegister, (int)AbusRegisterBF.Bus_En, 4 ),
				new BitFieldDef( (int)SourceRegister.RFUtility, (int)RFUtilityBF.BB_DAC_CLR_N, 0 ),
				new BitFieldDef( (int)SourceRegister.RFUtility, (int)RFUtilityBF.INCLK_EN, 1 ),
				new BitFieldDef( (int)SourceRegister.RFUtility, (int)RFUtilityBF.RF_BLANKING_MODE, 2, 3 ),
				new BitFieldDef( (int)SourceRegister.RFUtility, (int)RFUtilityBF.FPGA_INT_EN, 4 ),
				new BitFieldDef( (int)SourceRegister.RFUtility, (int)RFUtilityBF.TRIG_SRC, 5, 6 ),
				new BitFieldDef( (int)SourceRegister.RFUtility, (int)RFUtilityBF.SW_TRIG, 8 ),
				new BitFieldDef( (int)SourceRegister.RFUtility, (int)RFUtilityBF.RF_BLANKING_POLARITY, 9 ),
				new BitFieldDef( (int)SourceRegister.RfStatus, (int)RfStatusBF.P1V2_GD, 0 ),
				new BitFieldDef( (int)SourceRegister.RfStatus, (int)RfStatusBF.P2V5_GD, 1 ),
				new BitFieldDef( (int)SourceRegister.RfStatus, (int)RfStatusBF.LTC2666_OverTemp, 2 ),
				new BitFieldDef( (int)SourceRegister.ChipID_L, (int)ChipID_LBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceRegister.ChipID_H, (int)ChipID_HBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceRegister.RfFpgaVersion, (int)RfFpgaVersionBF.Rev, 0, 7 ),
				new BitFieldDef( (int)SourceRegister.RfFpgaVersion, (int)RfFpgaVersionBF.Minor, 8, 15 ),
				new BitFieldDef( (int)SourceRegister.RfFpgaVersion, (int)RfFpgaVersionBF.Major, 16, 24 ),
				new BitFieldDef( (int)SourceRegister.RfFpgaVersion, (int)RfFpgaVersionBF.BoardID, 29, 31 ),
				new BitFieldDef( (int)SourceRegister.RfFpgaSoftReset, (int)RfFpgaSoftResetBF.Reset, 31 ),
			};

		#endregion Member Variables

		#region Register Accessors
		public Reg32T<RFCntrl_pathBF> RFCntrl_path
		{
			get;
			private set;
		}
		public Reg32T<RFCntrl_PortBF> RFCntrl_Port
		{
			get;
			private set;
		}
		public Reg32T<LOCntrlBF> LOCntrl
		{
			get;
			private set;
		}
		public Reg32T<IQCntrlBF> IQCntrl
		{
			get;
			private set;
		}
		public Reg32T<PowerCntrlBF> PowerCntrl
		{
			get;
			private set;
		}
		public Reg32T<RFAttenBF> RFAtten
		{
			get;
			private set;
		}
		public Reg32T<TempSensorCntrlBF> TempSensorCntrl
		{
			get;
			private set;
		}
		public Reg32T<AbusRegisterBF> AbusRegister
		{
			get;
			private set;
		}
		public Reg32T<RFUtilityBF> RFUtility
		{
			get;
			private set;
		}
		public Reg32T<RfStatusBF> RfStatus
		{
			get;
			private set;
		}
		public Reg32T<ChipID_LBF> ChipID_L
		{
			get;
			private set;
		}
		public Reg32T<ChipID_HBF> ChipID_H
		{
			get;
			private set;
		}
		public Reg32T<RfFpgaVersionBF> RfFpgaVersion
		{
			get;
			private set;
		}
		public Reg32T<RfFpgaSoftResetBF> RfFpgaSoftReset
		{
			get;
			private set;
		}
		#endregion Register Accessors

		/// <summary>
		/// Creates the device register set (typed registers). Uses the 'default' BAR
		/// (which is normally specified in the register spreadsheet).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		public SourceRegisterSet( IRegManager manager, IInstrument module, string groupName )
			: this( manager, module, groupName, (int)BaseAddress.Source0, /*barIndex=*/0 )
		{
		}
		/// <summary>
		/// Creates the device register set (typed registers). Uses the 'default' BAR
		/// (which is normally specified in the register spreadsheet).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		/// <param name="registerSetOffset">an offset added to all register offsets</param>
		public SourceRegisterSet( IRegManager manager, IInstrument module, string groupName, int registerSetOffset )
			: this( manager, module, groupName, registerSetOffset, /*barIndex=*/0 )
		{
		}
		/// <summary>
		/// Creates the device register set (typed registers).
		/// Note that the BAR and offset can be specified by the caller so the same RegisterSet
		/// class can be used to define multiple unique RegisterSet instances (different offset
		/// and or BAR).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		/// <param name="registerSetOffset">an offset added to all register offsets</param>
		/// <param name="barIndex">the BAR to use</param>
		public SourceRegisterSet( IRegManager manager, IInstrument module, string groupName, int registerSetOffset, int barIndex )
		{
			// Create the factory
			RegFactory regFactory = new RegFactory( registerSetOffset, module, Reg32.ConstructReg );

			// Determine which IRegDriver (determines default BAR)
			IRegDriver regDriver = ( barIndex >= module.RegDrivers.Length ) ? null : module.RegDrivers[ barIndex ];
			if( regDriver == null )
			{
				throw new InternalApplicationException( "SourceRegisterSet requires RegDriver for BAR" + barIndex );
			}

			// Create the register definitions 
			Registers = regFactory.CreateRegArray(
				mRegisterDefinitions,
				typeof( SourceRegister ),
				regDriver,
				module.Name );

			regFactory.CreateBitFields( mBitFieldDefinitions, Registers, module.Name, string.Empty );

			if( manager != null )
			{
				// Adding as a group creates an IDirtyBit and attaches to each register
				manager.AddGroup( groupName, this );
			}
			RFCntrl_path = new Reg32T<RFCntrl_pathBF>((Reg32)Registers[ (Int32)SourceRegister.RFCntrl_path ]);
			RFCntrl_Port = new Reg32T<RFCntrl_PortBF>((Reg32)Registers[ (Int32)SourceRegister.RFCntrl_Port ]);
			LOCntrl = new Reg32T<LOCntrlBF>((Reg32)Registers[ (Int32)SourceRegister.LOCntrl ]);
			IQCntrl = new Reg32T<IQCntrlBF>((Reg32)Registers[ (Int32)SourceRegister.IQCntrl ]);
			PowerCntrl = new Reg32T<PowerCntrlBF>((Reg32)Registers[ (Int32)SourceRegister.PowerCntrl ]);
			RFAtten = new Reg32T<RFAttenBF>((Reg32)Registers[ (Int32)SourceRegister.RFAtten ]);
			TempSensorCntrl = new Reg32T<TempSensorCntrlBF>((Reg32)Registers[ (Int32)SourceRegister.TempSensorCntrl ]);
			AbusRegister = new Reg32T<AbusRegisterBF>((Reg32)Registers[ (Int32)SourceRegister.AbusRegister ]);
			RFUtility = new Reg32T<RFUtilityBF>((Reg32)Registers[ (Int32)SourceRegister.RFUtility ]);
			RfStatus = new Reg32T<RfStatusBF>((Reg32)Registers[ (Int32)SourceRegister.RfStatus ]);
			ChipID_L = new Reg32T<ChipID_LBF>((Reg32)Registers[ (Int32)SourceRegister.ChipID_L ]);
			ChipID_H = new Reg32T<ChipID_HBF>((Reg32)Registers[ (Int32)SourceRegister.ChipID_H ]);
			RfFpgaVersion = new Reg32T<RfFpgaVersionBF>((Reg32)Registers[ (Int32)SourceRegister.RfFpgaVersion ]);
			RfFpgaSoftReset = new Reg32T<RfFpgaSoftResetBF>((Reg32)Registers[ (Int32)SourceRegister.RfFpgaSoftReset ]);
		}

		/// <summary>
		/// Sets the initial values for the registers. Does not apply the values (write to HW).
		/// </summary>
		public override void SetInitialValues()
		{
			RFCntrl_path.Value = 1610612736;
			RFCntrl_Port.Value = 1605632;
			LOCntrl.Value = 0;
			IQCntrl.Value = 2;
			PowerCntrl.Value = 0;
			RFAtten.Value = 1073741823;
			TempSensorCntrl.Value = 1;
			AbusRegister.Value = 7;
			RFUtility.Value = 515;
			RfFpgaSoftReset.Field( RfFpgaSoftResetBF.Reset ).Value = 0;
		}
	}

	#endregion RegisterSets
}
