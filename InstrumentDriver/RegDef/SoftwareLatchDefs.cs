using System;
using InstrumentDriver.Core;
using InstrumentDriver.Core.Register;
using InstrumentDriver.Core.Interfaces;
using InstrumentDriver.Core.Utility;

namespace InstrumentDriver.NewInstrument
{

	// DO NOT EDIT THIS FILE.
	// This file was generated on 2020/1/26 23:08:41 from C:\TEMP\SoftwareLatchDefs.xlsx
	// by D:\Programs\MyRegisterFileTool\RegisterFileTool\bin\Debug\MyRegisterFileTool.exe version 1.5.5.0


	#region RegisterSets
	public class SoftwareLatchesRegisterSet : AbstractRegisterSet
	{

		#region Base Address(es) / Group Offset(s)

		// These are the base addresses (group offsets) defined by the register spreadsheet.
		// The client code will normally instantiate an instance of the register set for each.
		[System.Reflection.Obfuscation( Exclude = true )]
		public enum BaseAddress
		{
			SoftwareLatches0 = 0x10000,
		}

		#endregion Base Address(es)

		#region Cornerstone Register enums

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SoftwareLatchesRegister
		{
			LatchOne, // 0x0000 (0x10000) 
			TxSwLatch1, // 0x0008 (0x10008) 
			RxSwLatch1, // 0x0010 (0x10010) 
		}

		/// <summary>
		/// Register offset from original register definition (excludes 'Base').
		/// </summary>
		/// <remarks>
		/// The actual/runtime register offset is affected by parameters passed to the
		/// register factory and may not match the values defined here.
		/// </remarks>
		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SoftwareLatchesRegisterOffsets
		{
			LatchOne = 0x0000, // 
			TxSwLatch1 = 0x0008, // 
			RxSwLatch1 = 0x0010, // 
		}

		#endregion Cornerstone Register enums

		#region Cornerstone Register bitfield enums

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum LatchOneBF
		{
			Zero,                // Bit   0 		 
			One,                 // Bit   1 		 
			Two,                 // Bit   2 		 
			Many,                // Bits  3-63 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TxSwLatch1BF
		{
			TempCompOn,          // Bit   0 		 
			CalFilterUseIQAlignOnly, // Bit   1 		 
			CalFilterPreComputeAllTerms, // Bit   2 		 
			UseIFCorrection,     // Bit   3 		 
			UseResidualIFCorrection, // Bit   4 		 
			UseRFOutputCorrection, // Bit   5 		 
			UseSWCalFilter,      // Bit   6 		 
			UseIQMapCalOffsetCorrection, // Bit   7 		 
			EnableCCTrim,        // Bit   8 		 
			EnableCalFilter,     // Bit   9 		 
			UsingPolynomialFitting, // Bit  10 		 
			UseRfCorrection,     // Bit  11 		 
			RfChannelLock,       // Bit  12 		 
			HardwareBandLock,    // Bits 13-18 		 Cannot accept negative value. Value = HardwareBandLock + 10
			SoftwareBandLock,    // Bits 19-24 		 Cannot accept negative value. Value = SoftwareBandLock + 10
			CurrentHardwareBand, // Bits 25-30 		 Current hardware band number, read only
			CurrentSoftwareBand, // Bits 31-36 		 Current softwareware band number, read only
			IQDriveLevel_nmdB,   // Bits 37-52 		 IQDriveLevel in negative mdB. Range[0,40000]
			UseHwCalFilter,      // Bit  53 		 
			UseRfCalTable,       // Bit  54 		 
			UseRfGainCorrection, // Bit  55 		 
			UseTempCorrection,   // Bit  56 		 
			IQDriveLevel_sign,   // Bit  57 		 default value=0,means negative, 1 is postive
			Many,                // Bits 58-63 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RxSwLatch1BF
		{
			TempCompOn,          // Bit   0 		 
			CalFilterUseIQAlignOnly, // Bit   1 		 
			CalFilterPreComputeAllTerms, // Bit   2 		 
			UseIFCorrection,     // Bit   3 		 
			UseResidualIFCorrection, // Bit   4 		 
			UseRFInputCorrection, // Bit   5 		 
			UseSWCalFilter,      // Bit   6 		 
			UseIQMapCalOffsetCorrection, // Bit   7 		 
			EnableCCTrim,        // Bit   8 		 
			EnableCalFilter,     // Bit   9 		 
			UsingPolynomialFitting, // Bit  10 		 
			UseRFCorrection,     // Bit  11 		 
			SaveRawData,         // Bit  12 		 
			SaveScaledData,      // Bit  13 		 
			RfChannelLock,       // Bit  14 		 
			FeGainStateAuto,     // Bit  15 		 
			FeGainState,         // Bits 16-24 		 Cannot accept negative value. Value = FeGainState + 100
			HardwareBandLock,    // Bits 25-30 		 Cannot accept negative value. Value = HardwareBandLock + 10
			SoftwareBandLock,    // Bits 31-36 		 Cannot accept negative value. Value = SoftwareBandLock + 10
			CurrentHardwareBand, // Bits 37-42 		 Current hardware band number, read only
			CurrentSoftwareBand, // Bits 43-48 		 Current softwareware band number, read only
			UseResidualIFWholeCorrection, // Bit  49 		 
			UseHwCalFilter,      // Bit  50 		 
			Many,                // Bits 51-63 		 
		}

		#endregion Cornerstone Register bitfield enums

		#region Member Variables

		private static readonly RegDef[] mRegisterDefinitions = new[]
			{
				new RegDef((int) SoftwareLatchesRegister.LatchOne, 0x0000, typeof(LatchOneBF), RegType.RW, 64 ),
				new RegDef((int) SoftwareLatchesRegister.TxSwLatch1, 0x0008, typeof(TxSwLatch1BF), RegType.RW, 64 ),
				new RegDef((int) SoftwareLatchesRegister.RxSwLatch1, 0x0010, typeof(RxSwLatch1BF), RegType.RW, 64 ),
			};

		private static readonly BitFieldDef[] mBitFieldDefinitions = new []
			{
				// NOTE: using 'typeof( LatchOneBF )' will initialize the fields of all registers using that type
				new BitFieldDef( typeof( LatchOneBF ), (int)LatchOneBF.Zero, 0 ),
				new BitFieldDef( typeof( LatchOneBF ), (int)LatchOneBF.One, 1 ),
				new BitFieldDef( typeof( LatchOneBF ), (int)LatchOneBF.Two, 2 ),
				new BitFieldDef( typeof( LatchOneBF ), (int)LatchOneBF.Many, 3, 63 ),
				// NOTE: using 'typeof( TxSwLatch1BF )' will initialize the fields of all registers using that type
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.TempCompOn, 0 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.CalFilterUseIQAlignOnly, 1 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.CalFilterPreComputeAllTerms, 2 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseIFCorrection, 3 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseResidualIFCorrection, 4 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseRFOutputCorrection, 5 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseSWCalFilter, 6 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseIQMapCalOffsetCorrection, 7 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.EnableCCTrim, 8 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.EnableCalFilter, 9 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UsingPolynomialFitting, 10 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseRfCorrection, 11 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.RfChannelLock, 12 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.HardwareBandLock, 13, 18 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.SoftwareBandLock, 19, 24 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.CurrentHardwareBand, 25, 30 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.CurrentSoftwareBand, 31, 36 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.IQDriveLevel_nmdB, 37, 52 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseHwCalFilter, 53 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseRfCalTable, 54 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseRfGainCorrection, 55 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.UseTempCorrection, 56 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.IQDriveLevel_sign, 57 ),
				new BitFieldDef( typeof( TxSwLatch1BF ), (int)TxSwLatch1BF.Many, 58, 63 ),
				// NOTE: using 'typeof( RxSwLatch1BF )' will initialize the fields of all registers using that type
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.TempCompOn, 0 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.CalFilterUseIQAlignOnly, 1 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.CalFilterPreComputeAllTerms, 2 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.UseIFCorrection, 3 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.UseResidualIFCorrection, 4 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.UseRFInputCorrection, 5 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.UseSWCalFilter, 6 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.UseIQMapCalOffsetCorrection, 7 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.EnableCCTrim, 8 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.EnableCalFilter, 9 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.UsingPolynomialFitting, 10 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.UseRFCorrection, 11 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.SaveRawData, 12 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.SaveScaledData, 13 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.RfChannelLock, 14 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.FeGainStateAuto, 15 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.FeGainState, 16, 24 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.HardwareBandLock, 25, 30 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.SoftwareBandLock, 31, 36 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.CurrentHardwareBand, 37, 42 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.CurrentSoftwareBand, 43, 48 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.UseResidualIFWholeCorrection, 49 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.UseHwCalFilter, 50 ),
				new BitFieldDef( typeof( RxSwLatch1BF ), (int)RxSwLatch1BF.Many, 51, 63 ),
			};

		#endregion Member Variables

		#region Register Accessors
		public Reg64T<LatchOneBF> LatchOne
		{
			get;
			private set;
		}
		public Reg64T<TxSwLatch1BF> TxSwLatch1
		{
			get;
			private set;
		}
		public Reg64T<RxSwLatch1BF> RxSwLatch1
		{
			get;
			private set;
		}
		#endregion Register Accessors

		/// <summary>
		/// Creates the device register set (typed registers). Uses the 'default' BAR
		/// (which is normally specified in the register spreadsheet).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		public SoftwareLatchesRegisterSet( IRegManager manager, IInstrument module, string groupName )
			: this( manager, module, groupName, (int)BaseAddress.SoftwareLatches0, /*barIndex=*/0 )
		{
		}
		/// <summary>
		/// Creates the device register set (typed registers). Uses the 'default' BAR
		/// (which is normally specified in the register spreadsheet).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		/// <param name="registerSetOffset">an offset added to all register offsets</param>
		public SoftwareLatchesRegisterSet( IRegManager manager, IInstrument module, string groupName, int registerSetOffset )
			: this( manager, module, groupName, registerSetOffset, /*barIndex=*/0 )
		{
		}
		/// <summary>
		/// Creates the device register set (typed registers).
		/// Note that the BAR and offset can be specified by the caller so the same RegisterSet
		/// class can be used to define multiple unique RegisterSet instances (different offset
		/// and or BAR).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		/// <param name="registerSetOffset">an offset added to all register offsets</param>
		/// <param name="barIndex">the BAR to use</param>
		public SoftwareLatchesRegisterSet( IRegManager manager, IInstrument module, string groupName, int registerSetOffset, int barIndex )
		{
			// Create the factory
			RegFactory regFactory = new RegFactory( registerSetOffset, module, SimulatedReg.ConstructReg );

			// Determine which IRegDriver (determines default BAR)
			IRegDriver regDriver = ( barIndex >= module.RegDrivers.Length ) ? null : module.RegDrivers[ barIndex ];
			if( regDriver == null )
			{
				throw new InternalApplicationException( "SoftwareLatchesRegisterSet requires RegDriver for BAR" + barIndex );
			}

			// Create the register definitions 
			Registers = regFactory.CreateRegArray(
				mRegisterDefinitions,
				typeof( SoftwareLatchesRegister ),
				regDriver,
				module.Name );

			regFactory.CreateBitFields( mBitFieldDefinitions, Registers, module.Name, string.Empty );

			if( manager != null )
			{
				// Adding as a group creates an IDirtyBit and attaches to each register
				manager.AddGroup( groupName, this );
			}
			LatchOne = new Reg64T<LatchOneBF>((SimulatedReg)Registers[(Int32)SoftwareLatchesRegister.LatchOne]);
			TxSwLatch1 = new Reg64T<TxSwLatch1BF>((SimulatedReg)Registers[(Int32)SoftwareLatchesRegister.TxSwLatch1]);
			RxSwLatch1 = new Reg64T<RxSwLatch1BF>((SimulatedReg)Registers[(Int32)SoftwareLatchesRegister.RxSwLatch1]);
		}

		/// <summary>
		/// Sets the initial values for the registers. Does not apply the values (write to HW).
		/// </summary>
		public override void SetInitialValues()
		{
			LatchOne.Field( LatchOneBF.Zero ).Value = 0;
			LatchOne.Field( LatchOneBF.One ).Value = 0;
			LatchOne.Field( LatchOneBF.Two ).Value = 0;
			LatchOne.Field( LatchOneBF.Many ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.TempCompOn ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.CalFilterUseIQAlignOnly ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.CalFilterPreComputeAllTerms ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseIFCorrection ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseResidualIFCorrection ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseRFOutputCorrection ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseSWCalFilter ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseIQMapCalOffsetCorrection ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.EnableCCTrim ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.EnableCalFilter ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UsingPolynomialFitting ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseRfCorrection ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.RfChannelLock ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.HardwareBandLock ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.SoftwareBandLock ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.CurrentHardwareBand ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.CurrentSoftwareBand ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.IQDriveLevel_nmdB ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseHwCalFilter ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseRfCalTable ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseRfGainCorrection ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.UseTempCorrection ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.IQDriveLevel_sign ).Value = 0;
			TxSwLatch1.Field( TxSwLatch1BF.Many ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.TempCompOn ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.CalFilterUseIQAlignOnly ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.CalFilterPreComputeAllTerms ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.UseIFCorrection ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.UseResidualIFCorrection ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.UseRFInputCorrection ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.UseSWCalFilter ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.UseIQMapCalOffsetCorrection ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.EnableCCTrim ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.EnableCalFilter ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.UsingPolynomialFitting ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.UseRFCorrection ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.SaveRawData ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.SaveScaledData ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.RfChannelLock ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.FeGainStateAuto ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.FeGainState ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.HardwareBandLock ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.SoftwareBandLock ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.CurrentHardwareBand ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.CurrentSoftwareBand ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.UseResidualIFWholeCorrection ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.UseHwCalFilter ).Value = 0;
			RxSwLatch1.Field( RxSwLatch1BF.Many ).Value = 0;
		}
	}

	#endregion RegisterSets
}
