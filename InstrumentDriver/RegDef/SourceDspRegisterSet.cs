using System;
using InstrumentDriver.Core;
using InstrumentDriver.Core.Register;
using InstrumentDriver.Core.Interfaces;
using InstrumentDriver.Core.Utility;

namespace InstrumentDriver.NewInstrument
{

	// DO NOT EDIT THIS FILE.
	// This file was generated on 2020/1/26 23:08:17 from C:\TEMP\SourceDspRegisterSet.xlsx
	// by D:\Programs\MyRegisterFileTool\RegisterFileTool\bin\Debug\MyRegisterFileTool.exe version 1.5.5.0


	#region RegisterSets
	public class SourceDspRegisterSet : AbstractRegisterSet
	{

		#region Base Address(es) / Group Offset(s)

		// These are the base addresses (group offsets) defined by the register spreadsheet.
		// The client code will normally instantiate an instance of the register set for each.
		[System.Reflection.Obfuscation( Exclude = true )]
		public enum BaseAddress
		{
			SourceDsp0 = 0x0,
		}

		#endregion Base Address(es)

		#region SourceRegisters Register enums

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SourceDspRegister
		{
			Event, // 0x80000 When an event occurs, its corresponding bit in the event register becomes set and stays set until explicitly cleared.  A write to the event register will clear all event bits corresponding to a ‘1’ in the write value.
			InterruptMask, // 0x80004 Whenever the bitwise AND of the Event register and InterruptMask results in a bit change from 0 to 1, an interrupt message will be sent to the host controller (ie the PCIe root complex). Note that if an event bit had been set earlier but the corresponding interrupt mask bit had not been, then simply setting the mask bit to a 1 will cause an immediate interrupt message to be sent.  The InterruptMask bits are set and cleared with the InterruptMaskSet and InterruptMaskClear.
			InterruptEvent, // 0x80008 This register is the bitwise AND of Event and InterruptMask.
			InterruptMaskSet, // 0x80010 Writing this register will perform a bitwise OR with the InterruptMask, so any bit set in the InterruptMaskSet will get set in the InterruptMask.
			InterruptMaskClear, // 0x80014 Writing this register will perform a bitwise AND of the InterruptMask and the inverse of InterruptMaskClear, so any bits set in InterruptMaskClear will get cleared in the InterruptMask.
			Command, // 0x80018 This register provides a single location to invoke single-shot actions.  Only a single bit should be a 1 at a time, otherwise what happens is undefined.
			SourceDspEnables, // 0x8001c This register contains a bit field to enable or bypass each of the DSP blocks in the VXT 2 source DSP chain.  0 = bypass.  1 = enable.  The default value of 0 causes all source DSP blocks to be bypassed.
			InputFifoConfig, // 0x80088 0=Use all incoming data bits on both I and Q as data.  User marks come in on s_axis_tuser[3:0].  1=Use the 4 least significant bits of the I data as user marks.   This setting is ignored when InputPackingSize=InputPackedAs16Bits.  When InputPackingSize=InputPackedAs32Bits, bits 3 to 0 of I are used as the user marks, while bits 31 to 4 are used as the data.
			NumArbSamplesBeforeRepeating, // 0x8008c Since the incoming data comes in 256-bit packets, this means that either 4  or 8 (depending on if InputPackedAs32Bits or InputPackedAs16Bits, respectively) are input at a time.  However, a repeating waveform might have a length that is not a multiple of 4 or 8.  This register is use to skip samples between waveform repetitions for the cases when the number of IQ samples in a waveform are not a multiple of 4 or 8.  Only works correctly when NumSamplesPerClock is OneSamplePerClock.
			StartArbBlockRamAddr, // 0x80020 
			StopArbBlockRamAddr, // 0x80024 
			DisableInfiniteLooping, // 0x80028 
			NoiseGain, // 0x8002c 
			InputSignalGain, // 0x80030 
			NoiseSeedNormal, // 0x80034 Sets the 32-bit seed for the normal distributed noise generator. This seed is reapplied each time the ReseedNoiseStrobe is set.
			ChannelFilterControl, // 0x8009c 
			ChannelFilterWriteRe, // 0x800a0 
			ChannelFilterWriteIm, // 0x800a4 
			CoarseTimeStep, // 0x80038 
			FineTimeStep, // 0x8003c 
			FineTimeModulus, // 0x80040 
			NcoCoarsePhaseStep, // 0x80044 
			NcoFinePhaseStep, // 0x80048 
			NcoFinePhaseModulus, // 0x8004c 
			CorrectionFilterControl, // 0x80090 
			CorrectionFilterWriteRe, // 0x80094 
			CorrectionFilterWriteIm, // 0x80098 
			ArbPlaybackDuration, // 0x80050 Number of 375 MHz clock cycles to play back a subset of waveform.  After this number of clock cycles elapses,  the source state machine will automatically transition from the Run state to the Idle state without needing a StopStrobe.  Set this register to zero to disable.
			SourceStateMachineControl, // 0x80054 
			ArmConfig, // 0x80058 Arm configuration register
			TriggerConfig, // 0x8005c Trigger configuration register
			PauseConfig, // 0x80060 Pause configuration register
			StopConfig, // 0x80064 Stop configuration register
			DacConstant, // 0x80068 
			TriggerDelay, // 0x8006c Sets the delay between the external trigger and the start of the arb playback.  This unsigned value determines the number of 375 MHz clock periods will go by between when an external trigger occurs to when the state machine transitions from the Trigger state to the Run state.  This register is most useful when TriggerSource is ExternalTrigger.
			TriggerHoldOff, // 0x80070 This 32-bit unsigned register determines the minimum number of 375 MHz clock periods between external triggers.  Once an external trigger occurs, the next external trigger  will not be allowed to occur until the specified number of clock cycles set by this register have gone by.  Setting this register to either 0 or 1 effectively disables the trigger hold-off.  This register is most useful when TriggerSource is ExternalTrigger
			AutoTriggerTime, // 0x80074 This register determines how much time (in number of 375 MHz clock cycles) elapses before a trigger is automatically generated.  If a trigger signal is not received before the specified auto trigger time, then the source state machine will automatically transition from the Trigger to Run state. Setting this register to 0 disables auto triggering which makes the source state machine wait infinitely long for a trigger. Setting this register > 0 will cause a counter to count this many 375 MHz clock cycles before automatically generating the trigger.
			IGain, // 0x80078 
			QGain, // 0x8007c 
			PowerServoLogGain, // 0x800b0 
			PowerServoCurrentLogGain, // 0x800b4 
			PowerServoMinLogGain, // 0x800b8 
			PowerServoMaxLogGain, // 0x800bc 
			IOffset, // 0x80080 Signed 32-bit value representing a DC offset to apply to the I channel in the VariableGainAndOffset module.
			QOffset, // 0x80084 Signed 32-bit value representing a DC offset to apply to the Q channel in the VariableGainAndOffset module.
			IQGain, // 0x800c0 
			InputDataCounter, // 0x800a8 Counter containing the number of input packets that have occurred since the last startStrobe.  The counter increases by one every time (s_axis_tvalid==1 && s_axis_tready==1).
			OutputDataCounter, // 0x800ac Counter containing the number of output packets that have occurred since the last startStrobe.  The counter increases by one every time (m_axis_tvalid==1 && m_axis_tready==1).
			CorrectionFilterCoefficientMemory, // 0x84000 Correction Filter Coefficient Memory span base address. Access location within CorrectionFilterCoefficientMemory span is specified by { s_axi_awaddr[(log2CoefficientSetsCount + useGeneralized2x2Fir +  log2FftLength):0] }. That is, all coefficient sets and matrix elements are mapped on the CorrectionFilterCoefficientMemory span. Each address accesses 18-bit 2's complement FFT coefficient with real components at even addresses and imaginary components at odd addresses. Must write real component first followed by imaginary component!
			ArbBlockRamIqData, // 0x90000 Arbitrary Waveform RAM made from block RAMs within the FPGA.  Holds 8192 IQ samples.   Each IQ sample is 32 bits where the least significant 16 bits are I data and the most significant bit are  Q data.
			ArbBlockRamUserMarks, // 0x98000 Arbitrary Waveform RAM made from block RAMs within the FPGA.  Holds 8192 user marks.   Each userMark is 4 bits wide.
		}

		/// <summary>
		/// Register offset from original register definition (excludes 'Base').
		/// </summary>
		/// <remarks>
		/// The actual/runtime register offset is affected by parameters passed to the
		/// register factory and may not match the values defined here.
		/// </remarks>
		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SourceDspRegisterOffsets
		{
			Event = 0x0000, // When an event occurs, its corresponding bit in the event register becomes set and stays set until explicitly cleared.  A write to the event register will clear all event bits corresponding to a ‘1’ in the write value.
			InterruptMask = 0x0004, // Whenever the bitwise AND of the Event register and InterruptMask results in a bit change from 0 to 1, an interrupt message will be sent to the host controller (ie the PCIe root complex). Note that if an event bit had been set earlier but the corresponding interrupt mask bit had not been, then simply setting the mask bit to a 1 will cause an immediate interrupt message to be sent.  The InterruptMask bits are set and cleared with the InterruptMaskSet and InterruptMaskClear.
			InterruptEvent = 0x0008, // This register is the bitwise AND of Event and InterruptMask.
			InterruptMaskSet = 0x0010, // Writing this register will perform a bitwise OR with the InterruptMask, so any bit set in the InterruptMaskSet will get set in the InterruptMask.
			InterruptMaskClear = 0x0014, // Writing this register will perform a bitwise AND of the InterruptMask and the inverse of InterruptMaskClear, so any bits set in InterruptMaskClear will get cleared in the InterruptMask.
			Command = 0x0018, // This register provides a single location to invoke single-shot actions.  Only a single bit should be a 1 at a time, otherwise what happens is undefined.
			SourceDspEnables = 0x001c, // This register contains a bit field to enable or bypass each of the DSP blocks in the VXT 2 source DSP chain.  0 = bypass.  1 = enable.  The default value of 0 causes all source DSP blocks to be bypassed.
			InputFifoConfig = 0x0088, // 0=Use all incoming data bits on both I and Q as data.  User marks come in on s_axis_tuser[3:0].  1=Use the 4 least significant bits of the I data as user marks.   This setting is ignored when InputPackingSize=InputPackedAs16Bits.  When InputPackingSize=InputPackedAs32Bits, bits 3 to 0 of I are used as the user marks, while bits 31 to 4 are used as the data.
			NumArbSamplesBeforeRepeating = 0x008c, // Since the incoming data comes in 256-bit packets, this means that either 4  or 8 (depending on if InputPackedAs32Bits or InputPackedAs16Bits, respectively) are input at a time.  However, a repeating waveform might have a length that is not a multiple of 4 or 8.  This register is use to skip samples between waveform repetitions for the cases when the number of IQ samples in a waveform are not a multiple of 4 or 8.  Only works correctly when NumSamplesPerClock is OneSamplePerClock.
			StartArbBlockRamAddr = 0x0020, // 
			StopArbBlockRamAddr = 0x0024, // 
			DisableInfiniteLooping = 0x0028, // 
			NoiseGain = 0x002c, // 
			InputSignalGain = 0x0030, // 
			NoiseSeedNormal = 0x0034, // Sets the 32-bit seed for the normal distributed noise generator. This seed is reapplied each time the ReseedNoiseStrobe is set.
			ChannelFilterControl = 0x009c, // 
			ChannelFilterWriteRe = 0x00a0, // 
			ChannelFilterWriteIm = 0x00a4, // 
			CoarseTimeStep = 0x0038, // 
			FineTimeStep = 0x003c, // 
			FineTimeModulus = 0x0040, // 
			NcoCoarsePhaseStep = 0x0044, // 
			NcoFinePhaseStep = 0x0048, // 
			NcoFinePhaseModulus = 0x004c, // 
			CorrectionFilterControl = 0x0090, // 
			CorrectionFilterWriteRe = 0x0094, // 
			CorrectionFilterWriteIm = 0x0098, // 
			ArbPlaybackDuration = 0x0050, // Number of 375 MHz clock cycles to play back a subset of waveform.  After this number of clock cycles elapses,  the source state machine will automatically transition from the Run state to the Idle state without needing a StopStrobe.  Set this register to zero to disable.
			SourceStateMachineControl = 0x0054, // 
			ArmConfig = 0x0058, // Arm configuration register
			TriggerConfig = 0x005c, // Trigger configuration register
			PauseConfig = 0x0060, // Pause configuration register
			StopConfig = 0x0064, // Stop configuration register
			DacConstant = 0x0068, // 
			TriggerDelay = 0x006c, // Sets the delay between the external trigger and the start of the arb playback.  This unsigned value determines the number of 375 MHz clock periods will go by between when an external trigger occurs to when the state machine transitions from the Trigger state to the Run state.  This register is most useful when TriggerSource is ExternalTrigger.
			TriggerHoldOff = 0x0070, // This 32-bit unsigned register determines the minimum number of 375 MHz clock periods between external triggers.  Once an external trigger occurs, the next external trigger  will not be allowed to occur until the specified number of clock cycles set by this register have gone by.  Setting this register to either 0 or 1 effectively disables the trigger hold-off.  This register is most useful when TriggerSource is ExternalTrigger
			AutoTriggerTime = 0x0074, // This register determines how much time (in number of 375 MHz clock cycles) elapses before a trigger is automatically generated.  If a trigger signal is not received before the specified auto trigger time, then the source state machine will automatically transition from the Trigger to Run state. Setting this register to 0 disables auto triggering which makes the source state machine wait infinitely long for a trigger. Setting this register > 0 will cause a counter to count this many 375 MHz clock cycles before automatically generating the trigger.
			IGain = 0x0078, // 
			QGain = 0x007c, // 
			PowerServoLogGain = 0x00b0, // 
			PowerServoCurrentLogGain = 0x00b4, // 
			PowerServoMinLogGain = 0x00b8, // 
			PowerServoMaxLogGain = 0x00bc, // 
			IOffset = 0x0080, // Signed 32-bit value representing a DC offset to apply to the I channel in the VariableGainAndOffset module.
			QOffset = 0x0084, // Signed 32-bit value representing a DC offset to apply to the Q channel in the VariableGainAndOffset module.
			IQGain = 0x00c0, // 
			InputDataCounter = 0x00a8, // Counter containing the number of input packets that have occurred since the last startStrobe.  The counter increases by one every time (s_axis_tvalid==1 && s_axis_tready==1).
			OutputDataCounter = 0x00ac, // Counter containing the number of output packets that have occurred since the last startStrobe.  The counter increases by one every time (m_axis_tvalid==1 && m_axis_tready==1).
			CorrectionFilterCoefficientMemory = 0x4000, // Correction Filter Coefficient Memory span base address. Access location within CorrectionFilterCoefficientMemory span is specified by { s_axi_awaddr[(log2CoefficientSetsCount + useGeneralized2x2Fir +  log2FftLength):0] }. That is, all coefficient sets and matrix elements are mapped on the CorrectionFilterCoefficientMemory span. Each address accesses 18-bit 2's complement FFT coefficient with real components at even addresses and imaginary components at odd addresses. Must write real component first followed by imaginary component!
			ArbBlockRamIqData = 0x10000, // Arbitrary Waveform RAM made from block RAMs within the FPGA.  Holds 8192 IQ samples.   Each IQ sample is 32 bits where the least significant 16 bits are I data and the most significant bit are  Q data.
			ArbBlockRamUserMarks = 0x18000, // Arbitrary Waveform RAM made from block RAMs within the FPGA.  Holds 8192 user marks.   Each userMark is 4 bits wide.
		}

		#endregion SourceRegisters Register enums

		#region SourceRegisters Register bitfield enums

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum EventBF
		{
			DspOverflowOccurred, // Bit   2 		 A fixed-point math overflow occurred in one of the source DSP FPGA blocks
			DacUnderflow,        // Bit   3 		 This event gets set when the DAC needs IQ data and the source DSP isn’t able to provide it.  This occurs if the source DSP is not able to keep up with the full rate data needed by the DAC.  This event bit will only get set if there is a missing IQ sample going to the DAC after the first IQ sample is successfully sent.
			EnteredIdleState,    // Bit   4 		 The source state machine entered the Idle state
			EnteredArmingState,  // Bit   5 		 The source  state machine entered the Arming state
			EnteredTriggerState, // Bit   6 		 The source state machine entered the Trigger state
			EnteredRunState,     // Bit   7 		 The source state machine entered the Run state
			UserMark0,           // Bit   8 		 UserMark0 reached the DAC interface
			UserMark1,           // Bit   9 		 UserMark1 reached the DAC interface
			UserMark2,           // Bit  10 		 UserMark2 reached the DAC interface
			UserMark3,           // Bit  11 		 UserMark3 reached the DAC interface
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CommandBF
		{
			StartStrobe,         // Bit   0 		 Starts an arbitrary waveform playback by moving the source state machine from the Idle state to the Arm state.
			ArmStrobe,           // Bit   1 		 When ArmSource = ArmStrobe, writing a 1 to this bit moves the source state machine from the Arm state to the Trigger state.
			SoftwareTriggerStrobe, // Bit   2 		 When the trigger source is Software, writing this bit generates the trigger.
			StopStrobe,          // Bit   3 		 Aborts the currently playing arbitrary waveform by immediately moving the source state machine  to the Idle state.
			ResetRegistersStrobe, // Bit   4 		 Changes all registers values back to their reset state.
			PauseStrobe,         // Bit   5 		 If the source state machine is in the run state, then the PauseStrobe moves the source state machine back to the Trigger state.  The  IQ data sent to the DAC while "paused" is the IQ level that occurred at the instant the PauseStrobe was received.  A trigger (as determined by TriggerSource) is needed to undo the "pause" state.
			ReseedNoiseStrobe,   // Bit   6 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SourceDspEnablesBF
		{
			EnableSourceInputFifo, // Bit   0 		 
			EnableArbBlockRam,   // Bit   1 		 
			EnableNoiseGenerator, // Bit   2 		 
			EnableChannelFilter, // Bit   3 		 
			EnableArbitraryInterpolator, // Bit   4 		 
			EnableInterpolateBy4, // Bit   5 		 
			EnableNcoAndMixer,   // Bit   6 		 
			EnableCorrectionFilter, // Bit   7 		 
			EnableSourceStateMachine, // Bit   9 		 
			EnableVariableGainAndOffset, // Bit  10 		 
			EnablePackAs16Bits,  // Bit  11 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum InputFifoConfigBF
		{
			UseLsbsAsUserMarks,  // Bit   2 		 0=Use all incoming data bits on both I and Q as data.  User marks come in on s_axis_tuser[3:0].  1=Use the 4 least significant bits of the I data as user marks.   This setting is ignored when InputPackingSize=InputPackedAs16Bits.  When InputPackingSize=InputPackedAs32Bits, bits 3 to 0 of I are used as the user marks, while bits 31 to 4 are used as the data.
			NumSamplesPerClock,  // Bit   1 		 Determines the number of IQ samples output from the FIFO per 375 MHz clock period.   Data going into the FIFO is always 256 bits wide, which is either 4 IQ samples when InputPackingSize==InputPackedAs32Bits, or 8 IQ samples when InputPackingSize==InputPackedAs16Bits.  However, data coming out of the FIFO can only be 1 IQ sample per clock period, or 4 IQ samples per clock period.  Reverse flow control (using the in_ready signal) is used to pause the incoming stream as necessary.
			InputPackingSize,    // Bit   0 		 Determines if the input data going into the FIFO should be treated as 16-bit or 32-bit data.  Note that the FIFO always outputs 32 bits data.  When the input is packed as 16 bits, the 16-bit data will be put into the 16 most significant bits of the 32-bit output data, while the 16 least significant bits will be set to zeros.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum NumArbSamplesBeforeRepeatingBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum StartArbBlockRamAddrBF
		{
			Address,             // Bits  0-13 		 Starting RAM address (0 to 8191) to play out when StartStrobe is received.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum StopArbBlockRamAddrBF
		{
			Address,             // Bits  0-13 		 Ending RAM address (0 to 8191) to output
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum DisableInfiniteLoopingBF
		{
			Disable,             // Bit   0 		 0: Loop back to StartArbBlockRamAddr after StopArbBlockRamAddr.  1: Stop playback after reaching StopArbBlockRamAddr
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum NoiseGainBF
		{
			Gain,                // Bits  0-17 		 Signed 18-bit value representing  gain to apply to AWGN noise.  Set to 0 to effectively disable the noise generator.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum InputSignalGainBF
		{
			Gain,                // Bits  0-17 		 Signed 18-bit value representing  gain to apply to input signal noise.  A value of 0x10000 represents unity (1.0) gain.  Setting this scaling factor less than one is important to avoid having noise peaks cause overloads in the DSP chain when using the noise generator.  This is especially important when the NoiseGain is large.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum NoiseSeedNormalBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelFilterControlBF
		{
			DspSetSelect,        // Bit  30 		 Zero-based index of the frequency domain coefficient set used by the DSP.
			CtrlWriteEnable,     // Bit  29 		 The control port write enable.
			CtrlSetSelect,       // Bit  27 		 Zero-based index of the frequency domain coefficient set to the control port.
			CtrlReadBackModeEnabled, // Bit  13 		 Enables control port coefficient read back diagnostic override mode. Must be disabled for proper DSP operation!
			CtrlAddress,         // Bits  0-12 		 Zero-based index of frequency domain coefficient to the control port. Superfluous bits at positions greater than or equal to log2(FftLength) are ignored/truncated such that assignments at address FftLength and above alias to the range [0, FftLength).
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelFilterWriteReBF
		{
			Real,                // Bits  0-17 		 Real component of frequency domain coefficient to be written (signed 18 bits, 15 fractional bits).
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelFilterWriteImBF
		{
			Imag,                // Bits  0-17 		 Imaginary component of frequency domain coefficient to be written (signed 18 bits, 15 fractional bits).
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CoarseTimeStepBF
		{
			CoarseTimeStep,      // Bits  0-23 		 This register is used to set the coarse resolution of the arbitrary interpolator   CoarseTimeStep = floor(2^24 / decimationFactor)
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum FineTimeStepBF
		{
			FineTimeStep,        // Bits  0-23 		 Used to set a finer resolution time step than can be achieved by CoarseTimeStep alone.  FineTimeStep = round( 2^24 * (FineTimeModulus + 1) / decimationFactor - CoarseTimeStep * (FineTimeModulus + 1))
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum FineTimeModulusBF
		{
			FineTimeModulus,     // Bits  0-23 		 Used in conjunction with FineTimeStep to achieve a finer resolution time step than can be achieved by CoarseTimeStep alone.  It is recommended to set FineTimeModulus = 6*5^9- 1, which allows the output sample rate from the ArbitraryInterpolator to exactly achieve any rate that is a multiple of 1 Hz.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum NcoCoarsePhaseStepBF
		{
			NcoCoarsePhaseStep,  // Bits  0-23 		 This register is used to set the coarse resolution of the NCO.   NcoCoarsePhaseStep = (int)Math.Floor((1 << 24) * normalizedFreq), where normalizedFreq is between 0 and 1.  The NCO sets the baseband frequency which effectively offsets the frequency from the Wyvern LO frequency.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum NcoFinePhaseStepBF
		{
			NcoFinePhaseStep,    // Bits  0-23 		 Used to set a finer resolution phase step than can be achieved by NcoCoarsePhaseStep alone.  NcoFinePhaseStep =(int)Math.Round((1 << 24) * (NcoFinePhaseModulus + 1L) * normalizedFreq - NcoCoarsePhaseStep * (NcoFinePhaseModulus + 1L))
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum NcoFinePhaseModulusBF
		{
			NcoFinePhaseModulus, // Bits  0-23 		 Used in conjunction with NcoFinePhaseStep to achieve a finer resolution time step than can be achieved by NcoCoarsePhaseStep alone.  It is recommended to set NcoFinePhaseModulus =  = 6×5^9 - 1, which allows the input sample rate from the NCO to exactly achieve any rate that is a multiple of 1 Hz when the DAC sample rate is 1.5 GHz (proto 2 hardware).
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CorrectionFilterControlBF
		{
			DspSetSelect,        // Bit  30 		 Zero-based index of the frequency domain coefficient set used by the DSP.
			CtrlWriteEnable,     // Bit  29 		 The control port write enable.
			CtrlSetSelect,       // Bit  27 		 Zero-based index of the frequency domain coefficient set to the control port.
			CtrlMatrixElementSelect, // Bit  26 		 Selected generalized 2x2 Matrix element of frequency domain coefficient to the control port.
			CtrlReadBackModeEnabled, // Bit  13 		 Enables control port coefficient read back diagnostic override mode. Must be disabled for proper DSP operation!
			CtrlAddress,         // Bits  0-12 		 Zero-based index of frequency domain coefficient to the control port. Superfluous bits at positions greater than or equal to log2(FftLength) are ignored/truncated such that assignments at address FftLength and above alias to the range [0, FftLength).
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CorrectionFilterWriteReBF
		{
			Real,                // Bits  0-17 		 Real component of frequency domain coefficient to be written (signed 18 bits, 16 fractional bits).
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CorrectionFilterWriteImBF
		{
			Imag,                // Bits  0-17 		 Imaginary component of frequency domain coefficient to be written (signed 18 bits, 16 fractional bits).
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ArbPlaybackDurationBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SourceStateMachineControlBF
		{
			HoldLastSample,      // Bit   0 		 0: output IDacConstant and QDacConstant to the DAC whenever the state machine transitions is in the Idle State.  1: output the last DAC IQ value that was being played when the state machine transitioned to the Idle state.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ArmConfigBF
		{
			ArmSource,           // Bits  0- 3 		 Determines the arm source.  This is what causes the source state machine to move from the Arm state to the Trigger State.
			ArmUserMark,         // Bits  4- 7 		 When ArmSource is UserMark, this field determines which of the 16 user marks will be used as the ArmSource
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TriggerConfigBF
		{
			TriggerSource,       // Bits  0- 3 		 Determines the trigger source for the measurement state machine.  The trigger source is what moves the source state machine from the Trigger state to the Run state and is what starts the arbitrary waveform playback to the DAC.
			TriggerUserMark,     // Bits  4- 7 		 When TriggerSource is UserMark, this field determines which of the 16 user marks will be used as the TriggerSource
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PauseConfigBF
		{
			PauseSource,         // Bits  0- 3 		 Determines the pause source for the measurement state machine.  When the source state machine is in the Run state, a pause signal will move the source state machine back to the Trigger state.
			PauseUserMark,       // Bits  4- 7 		 When PauseSource is UserMark, this field determines which of the 16 user marks is used as the PauseSource.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum StopConfigBF
		{
			StopSource,          // Bits  0- 3 		 Determines the stop source for the measurement state machine.  When the source state machine is in the Run state, a stop signal will move the source state machine to the Idle state.
			StopUserMark,        // Bits  4- 7 		 When StopSource is UserMark, this field determines which of the 16 user marks is used as the StopSource.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum DacConstantBF
		{
			IDacConstant,        // Bits  0-15 		 DAC value to output to the I DAC when in the IdleState and HoldLastSample=0
			QDacConstant,        // Bits 16-31 		 DAC value to output to the Q DAC when in the IdleState and HoldLastSample=0
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TriggerDelayBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TriggerHoldOffBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum AutoTriggerTimeBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum IGainBF
		{
			IGain,               // Bits  0-17 		 Signed 18-bit value representing a gain to apply to the I channel in the VariableGainAndOffset module.  A value of 0x10000 represents unity gain.  This register can be used to quickly change the baseband power, which is a very fast way to change the output RF power compared to changing attenuators on the source board.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum QGainBF
		{
			QGain,               // Bits  0-17 		 Signed 18-bit value representing a gain to apply to the Q channel in the VariableGainAndOffset module.  A value of 0x10000 (1.0) represents unity gain.  This register can be used to quickly change the baseband power, which is a very fast way to change the output RF power compared to changing attenuators on the source board.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PowerServoLogGainBF
		{
			PowerServoLogGain,   // Bits  0-13 		 Signed 14-bit value.  This parameter represents a gain from -20.48 dB to +20.48 dB in log units where each LSB represents 0.0025 dB.  This parameter is used by the FPGA power servo to digitally adjust the output power of the source.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PowerServoCurrentLogGainBF
		{
			PowerServoCurrentLogGain, // Bits  0-13 		 Signed 14-bit value.  This parameter represents a gain from -20.48 dB to +20.48 dB in log units where each LSB represents 0.0025 dB.   This read-only register is used to read back the current power servo log gain.  Typically this register is initially set via the PowerServoLogGain register, and then is adjusted at each loop of an FPGA power servo.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PowerServoMinLogGainBF
		{
			PowerServoMinLogGain, // Bits  0-13 		 Signed 14-bit value.  This parameter represents a gain from -20.48 dB to +20.48 dB in log units where each LSB represents 0.0025 dB.   This register limits the minimum gain that the FPGA power servo can adust the gain to.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PowerServoMaxLogGainBF
		{
			PowerServoMaxLogGain, // Bits  0-13 		 Signed 14-bit value.  This parameter represents a gain from -20.48 dB to +20.48 dB in log units where each LSB represents 0.0025 dB.   This register limits the maximum gain that the FPGA power servo can adust the gain to.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum IOffsetBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum QOffsetBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum IQGainBF
		{
			IQGain,              // Bits  0-17 		 Signed 18-bit value representing a linear gain to apply to both the I and Q channels in the VariableGainAndOffset module.  A value of 0x04000 represents unity gain.  This register can be used to quickly change the baseband power, which is a very fast way to change the output RF power compared to changing attenuators on the source board.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum InputDataCounterBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum OutputDataCounterBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CorrectionFilterCoefficientMemoryBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ArbBlockRamIqDataBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ArbBlockRamUserMarksBF
		{
			UserMarks,           // Bits  0- 3 		 
		}

		#endregion SourceRegisters Register bitfield enums

		#region SourceRegisters Register bitfield values

		/// <summary>
		/// Values for the SourceDsp Register: InputFifoConfig, Bitfield: NumSamplesPerClock
		/// </summary>
		public enum NumSamplesPerClockValues
		{
			FourSamplesPerClock=0, // The FIFO will output 4 IQ samples per 375 MHz clock period.
			OneSamplePerClock=1, // The FIFO will output 1 IQ sample per 375 MHz clock period.
		}

		/// <summary>
		/// Values for the SourceDsp Register: InputFifoConfig, Bitfield: InputPackingSize
		/// </summary>
		public enum InputPackingSizeValues
		{
			InputPackedAs16Bits=0, // Treat input as 16-bit data (16-bit I and 16-bit Q).
			InputPackedAs32Bits=1, // Treat input as 32-bit data (32-bit I and 32-bit Q).
		}

		/// <summary>
		/// Values for the SourceDsp Register: CorrectionFilterControl, Bitfield: CtrlMatrixElementSelect
		/// </summary>
		public enum CtrlMatrixElementSelectValues
		{
			Normal = 0, 
			Invert = 1, 
		}

		/// <summary>
		/// Values for the SourceDsp Register: ArmConfig, Bitfield: ArmSource
		/// </summary>
		public enum ArmSourceValues
		{
			Immediate=0, // The source state machine automatically and immediately goes from the Arm state to the Trigger state.
			ArmMark=1, // The source state machine will stay in the Arm state until an arm mark is received, which indicates that all digital filters have settled.
			ArmStrobe=2, // The source state machine will stay in the Arm state until a 1 is written to the ArmStrobe bit in the Command register.
			UserMark=3, // The source state machine will stay in the Arm state until the user mark selected by ArmUserMark flows to the SourceStateMachine
		}

		/// <summary>
		/// Values for the SourceDsp Register: TriggerConfig, Bitfield: TriggerSource
		/// </summary>
		public enum TriggerSourceValues
		{
			Immediate=0, // The source state machine automatically and immediately goes from the Trigger state to the Run state.
			ExternalTrigger=1, // The source state machine will stay in the Trigger state until an external trigger is received.
			SoftwareTriggerStrobe=2, // The source state machine will stay in the Trigger state until a 1 is written to the SoftwareTriggerStobe bit in the Command register.
			UserMark=3, // The source state machine will stay in the Trigger state until the user mark selected by TriggerUserMark flows to the SourceStateMachine
		}

		/// <summary>
		/// Values for the SourceDsp Register: PauseConfig, Bitfield: PauseSource
		/// </summary>
		public enum PauseSourceValues
		{
			Off=0, // Only a PauseStrobe can "pause" the state machine.
			ExternalTrigger=1, // An external trigger will move the source state machine from the Run state back to the Trigger state.  Note that a PauseStrobe can also "pause" the state machine.
			UserMark=3, // The user mark selected by PauseUserMark will move the source state machine from the Run state back to the Trigger state.  Note that a PauseStrobe can also "pause" the state machine.
		}

		/// <summary>
		/// Values for the SourceDsp Register: StopConfig, Bitfield: StopSource
		/// </summary>
		public enum StopSourceValues
		{
			Off=0, // Off.  Note that a StopStrobe will still move the source state machine to the Idle state.  Also the source state machine will automatically move from the Run state to the Idle state after the ArbPlaybackDuration time has expired.
			ExternalTrigger=1, // An external trigger will move the source state machine from the Run state back to the Idle state. Note that a StopStrobe or the expiration of the ArbPlaybackDuration can also move the source state machine to the Idle state.
			UserMark=3, // The user mark selected by StopUserMark will move the source state machine from the Run state to the Idle state.  Note that a StopStrobe or the expiration of the ArbPlaybackDuration can also move the source state machine to the Idle state.
		}

		#endregion SourceRegisters Register bitfield values

		#region Member Variables

		private static readonly RegDef[] mRegisterDefinitions = new[]
			{
				new RegDef((int) SourceDspRegister.Event, 0x80000, typeof(EventBF), RegType.Event ),
				new RegDef((int) SourceDspRegister.InterruptMask, 0x80004, typeof(EventBF), RegType.RO ),
				new RegDef((int) SourceDspRegister.InterruptEvent, 0x80008, typeof(EventBF), RegType.RO ),
				new RegDef((int) SourceDspRegister.InterruptMaskSet, 0x80010, typeof(EventBF), RegType.Cmd |RegType.NoForce ),
				new RegDef((int) SourceDspRegister.InterruptMaskClear, 0x80014, typeof(EventBF), RegType.Cmd |RegType.NoForce ),
				new RegDef((int) SourceDspRegister.Command, 0x80018, typeof(CommandBF), RegType.Cmd |RegType.NoForce ),
				new RegDef((int) SourceDspRegister.SourceDspEnables, 0x8001c, typeof(SourceDspEnablesBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.InputFifoConfig, 0x80088, typeof(InputFifoConfigBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.NumArbSamplesBeforeRepeating, 0x8008c, typeof(NumArbSamplesBeforeRepeatingBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.StartArbBlockRamAddr, 0x80020, typeof(StartArbBlockRamAddrBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.StopArbBlockRamAddr, 0x80024, typeof(StopArbBlockRamAddrBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.DisableInfiniteLooping, 0x80028, typeof(DisableInfiniteLoopingBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.NoiseGain, 0x8002c, typeof(NoiseGainBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.InputSignalGain, 0x80030, typeof(InputSignalGainBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.NoiseSeedNormal, 0x80034, typeof(NoiseSeedNormalBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.ChannelFilterControl, 0x8009c, typeof(ChannelFilterControlBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.ChannelFilterWriteRe, 0x800a0, typeof(ChannelFilterWriteReBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.ChannelFilterWriteIm, 0x800a4, typeof(ChannelFilterWriteImBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.CoarseTimeStep, 0x80038, typeof(CoarseTimeStepBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.FineTimeStep, 0x8003c, typeof(FineTimeStepBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.FineTimeModulus, 0x80040, typeof(FineTimeModulusBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.NcoCoarsePhaseStep, 0x80044, typeof(NcoCoarsePhaseStepBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.NcoFinePhaseStep, 0x80048, typeof(NcoFinePhaseStepBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.NcoFinePhaseModulus, 0x8004c, typeof(NcoFinePhaseModulusBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.CorrectionFilterControl, 0x80090, typeof(CorrectionFilterControlBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.CorrectionFilterWriteRe, 0x80094, typeof(CorrectionFilterWriteReBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.CorrectionFilterWriteIm, 0x80098, typeof(CorrectionFilterWriteImBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.ArbPlaybackDuration, 0x80050, typeof(ArbPlaybackDurationBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.SourceStateMachineControl, 0x80054, typeof(SourceStateMachineControlBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.ArmConfig, 0x80058, typeof(ArmConfigBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.TriggerConfig, 0x8005c, typeof(TriggerConfigBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.PauseConfig, 0x80060, typeof(PauseConfigBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.StopConfig, 0x80064, typeof(StopConfigBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.DacConstant, 0x80068, typeof(DacConstantBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.TriggerDelay, 0x8006c, typeof(TriggerDelayBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.TriggerHoldOff, 0x80070, typeof(TriggerHoldOffBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.AutoTriggerTime, 0x80074, typeof(AutoTriggerTimeBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.IGain, 0x80078, typeof(IGainBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.QGain, 0x8007c, typeof(QGainBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.PowerServoLogGain, 0x800b0, typeof(PowerServoLogGainBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.PowerServoCurrentLogGain, 0x800b4, typeof(PowerServoCurrentLogGainBF), RegType.RO ),
				new RegDef((int) SourceDspRegister.PowerServoMinLogGain, 0x800b8, typeof(PowerServoMinLogGainBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.PowerServoMaxLogGain, 0x800bc, typeof(PowerServoMaxLogGainBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.IOffset, 0x80080, typeof(IOffsetBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.QOffset, 0x80084, typeof(QOffsetBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.IQGain, 0x800c0, typeof(IQGainBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.InputDataCounter, 0x800a8, typeof(InputDataCounterBF), RegType.RO ),
				new RegDef((int) SourceDspRegister.OutputDataCounter, 0x800ac, typeof(OutputDataCounterBF), RegType.RO ),
				new RegDef((int) SourceDspRegister.CorrectionFilterCoefficientMemory, 0x84000, typeof(CorrectionFilterCoefficientMemoryBF), RegType.RO, 18 ),
				new RegDef((int) SourceDspRegister.ArbBlockRamIqData, 0x90000, typeof(ArbBlockRamIqDataBF), RegType.RW ),
				new RegDef((int) SourceDspRegister.ArbBlockRamUserMarks, 0x98000, typeof(ArbBlockRamUserMarksBF), RegType.RW ),
			};

		private static readonly BitFieldDef[] mBitFieldDefinitions = new []
			{
				// NOTE: using 'typeof( EventBF )' will initialize the fields of all registers using that type
				new BitFieldDef( typeof( EventBF ), (int)EventBF.DspOverflowOccurred, 2 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.DacUnderflow, 3 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.EnteredIdleState, 4 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.EnteredArmingState, 5 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.EnteredTriggerState, 6 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.EnteredRunState, 7 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.UserMark0, 8 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.UserMark1, 9 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.UserMark2, 10 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.UserMark3, 11 ),
				// NOTE: using 'typeof( CommandBF )' will initialize the fields of all registers using that type
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.StartStrobe, 0 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.ArmStrobe, 1 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.SoftwareTriggerStrobe, 2 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.StopStrobe, 3 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.ResetRegistersStrobe, 4 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.PauseStrobe, 5 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.ReseedNoiseStrobe, 6 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableSourceInputFifo, 0 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableArbBlockRam, 1 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableNoiseGenerator, 2 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableChannelFilter, 3 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableArbitraryInterpolator, 4 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableInterpolateBy4, 5 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableNcoAndMixer, 6 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableCorrectionFilter, 7 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableSourceStateMachine, 9 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnableVariableGainAndOffset, 10 ),
				new BitFieldDef( (int)SourceDspRegister.SourceDspEnables, (int)SourceDspEnablesBF.EnablePackAs16Bits, 11 ),
				new BitFieldDef( (int)SourceDspRegister.InputFifoConfig, (int)InputFifoConfigBF.UseLsbsAsUserMarks, 2 ),
				new BitFieldDef( (int)SourceDspRegister.InputFifoConfig, (int)InputFifoConfigBF.NumSamplesPerClock, 1 ),
				new BitFieldDef( (int)SourceDspRegister.InputFifoConfig, (int)InputFifoConfigBF.InputPackingSize, 0 ),
				new BitFieldDef( (int)SourceDspRegister.NumArbSamplesBeforeRepeating, (int)NumArbSamplesBeforeRepeatingBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.StartArbBlockRamAddr, (int)StartArbBlockRamAddrBF.Address, 0, 13 ),
				new BitFieldDef( (int)SourceDspRegister.StopArbBlockRamAddr, (int)StopArbBlockRamAddrBF.Address, 0, 13 ),
				new BitFieldDef( (int)SourceDspRegister.DisableInfiniteLooping, (int)DisableInfiniteLoopingBF.Disable, 0 ),
				new BitFieldDef( (int)SourceDspRegister.NoiseGain, (int)NoiseGainBF.Gain, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.InputSignalGain, (int)InputSignalGainBF.Gain, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.NoiseSeedNormal, (int)NoiseSeedNormalBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.ChannelFilterControl, (int)ChannelFilterControlBF.DspSetSelect, 30 ),
				new BitFieldDef( (int)SourceDspRegister.ChannelFilterControl, (int)ChannelFilterControlBF.CtrlWriteEnable, 29 ),
				new BitFieldDef( (int)SourceDspRegister.ChannelFilterControl, (int)ChannelFilterControlBF.CtrlSetSelect, 27 ),
				new BitFieldDef( (int)SourceDspRegister.ChannelFilterControl, (int)ChannelFilterControlBF.CtrlReadBackModeEnabled, 13 ),
				new BitFieldDef( (int)SourceDspRegister.ChannelFilterControl, (int)ChannelFilterControlBF.CtrlAddress, 0, 12 ),
				new BitFieldDef( (int)SourceDspRegister.ChannelFilterWriteRe, (int)ChannelFilterWriteReBF.Real, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.ChannelFilterWriteIm, (int)ChannelFilterWriteImBF.Imag, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.CoarseTimeStep, (int)CoarseTimeStepBF.CoarseTimeStep, 0, 23 ),
				new BitFieldDef( (int)SourceDspRegister.FineTimeStep, (int)FineTimeStepBF.FineTimeStep, 0, 23 ),
				new BitFieldDef( (int)SourceDspRegister.FineTimeModulus, (int)FineTimeModulusBF.FineTimeModulus, 0, 23 ),
				new BitFieldDef( (int)SourceDspRegister.NcoCoarsePhaseStep, (int)NcoCoarsePhaseStepBF.NcoCoarsePhaseStep, 0, 23 ),
				new BitFieldDef( (int)SourceDspRegister.NcoFinePhaseStep, (int)NcoFinePhaseStepBF.NcoFinePhaseStep, 0, 23 ),
				new BitFieldDef( (int)SourceDspRegister.NcoFinePhaseModulus, (int)NcoFinePhaseModulusBF.NcoFinePhaseModulus, 0, 23 ),
				new BitFieldDef( (int)SourceDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.DspSetSelect, 30 ),
				new BitFieldDef( (int)SourceDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlWriteEnable, 29 ),
				new BitFieldDef( (int)SourceDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlSetSelect, 27 ),
				new BitFieldDef( (int)SourceDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlMatrixElementSelect, 26 ),
				new BitFieldDef( (int)SourceDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlReadBackModeEnabled, 13 ),
				new BitFieldDef( (int)SourceDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlAddress, 0, 12 ),
				new BitFieldDef( (int)SourceDspRegister.CorrectionFilterWriteRe, (int)CorrectionFilterWriteReBF.Real, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.CorrectionFilterWriteIm, (int)CorrectionFilterWriteImBF.Imag, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.ArbPlaybackDuration, (int)ArbPlaybackDurationBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.SourceStateMachineControl, (int)SourceStateMachineControlBF.HoldLastSample, 0 ),
				new BitFieldDef( (int)SourceDspRegister.ArmConfig, (int)ArmConfigBF.ArmSource, 0, 3 ),
				new BitFieldDef( (int)SourceDspRegister.ArmConfig, (int)ArmConfigBF.ArmUserMark, 4, 7 ),
				new BitFieldDef( (int)SourceDspRegister.TriggerConfig, (int)TriggerConfigBF.TriggerSource, 0, 3 ),
				new BitFieldDef( (int)SourceDspRegister.TriggerConfig, (int)TriggerConfigBF.TriggerUserMark, 4, 7 ),
				new BitFieldDef( (int)SourceDspRegister.PauseConfig, (int)PauseConfigBF.PauseSource, 0, 3 ),
				new BitFieldDef( (int)SourceDspRegister.PauseConfig, (int)PauseConfigBF.PauseUserMark, 4, 7 ),
				new BitFieldDef( (int)SourceDspRegister.StopConfig, (int)StopConfigBF.StopSource, 0, 3 ),
				new BitFieldDef( (int)SourceDspRegister.StopConfig, (int)StopConfigBF.StopUserMark, 4, 7 ),
				new BitFieldDef( (int)SourceDspRegister.DacConstant, (int)DacConstantBF.IDacConstant, 0, 15 ),
				new BitFieldDef( (int)SourceDspRegister.DacConstant, (int)DacConstantBF.QDacConstant, 16, 31 ),
				new BitFieldDef( (int)SourceDspRegister.TriggerDelay, (int)TriggerDelayBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.TriggerHoldOff, (int)TriggerHoldOffBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.AutoTriggerTime, (int)AutoTriggerTimeBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.IGain, (int)IGainBF.IGain, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.QGain, (int)QGainBF.QGain, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.PowerServoLogGain, (int)PowerServoLogGainBF.PowerServoLogGain, 0, 13 ),
				new BitFieldDef( (int)SourceDspRegister.PowerServoCurrentLogGain, (int)PowerServoCurrentLogGainBF.PowerServoCurrentLogGain, 0, 13 ),
				new BitFieldDef( (int)SourceDspRegister.PowerServoMinLogGain, (int)PowerServoMinLogGainBF.PowerServoMinLogGain, 0, 13 ),
				new BitFieldDef( (int)SourceDspRegister.PowerServoMaxLogGain, (int)PowerServoMaxLogGainBF.PowerServoMaxLogGain, 0, 13 ),
				new BitFieldDef( (int)SourceDspRegister.IOffset, (int)IOffsetBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.QOffset, (int)QOffsetBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.IQGain, (int)IQGainBF.IQGain, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.InputDataCounter, (int)InputDataCounterBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.OutputDataCounter, (int)OutputDataCounterBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.CorrectionFilterCoefficientMemory, (int)CorrectionFilterCoefficientMemoryBF.Value, 0, 17 ),
				new BitFieldDef( (int)SourceDspRegister.ArbBlockRamIqData, (int)ArbBlockRamIqDataBF.Value, 0, 31 ),
				new BitFieldDef( (int)SourceDspRegister.ArbBlockRamUserMarks, (int)ArbBlockRamUserMarksBF.UserMarks, 0, 3 ),
			};

		#endregion Member Variables

		#region Register Accessors
		public Reg32T<EventBF> Event
		{
			get;
			private set;
		}
		public Reg32T<EventBF> InterruptMask
		{
			get;
			private set;
		}
		public Reg32T<EventBF> InterruptEvent
		{
			get;
			private set;
		}
		public Reg32T<EventBF> InterruptMaskSet
		{
			get;
			private set;
		}
		public Reg32T<EventBF> InterruptMaskClear
		{
			get;
			private set;
		}
		public Reg32T<CommandBF> Command
		{
			get;
			private set;
		}
		public Reg32T<SourceDspEnablesBF> SourceDspEnables
		{
			get;
			private set;
		}
		public Reg32T<InputFifoConfigBF> InputFifoConfig
		{
			get;
			private set;
		}
		public Reg32T<NumArbSamplesBeforeRepeatingBF> NumArbSamplesBeforeRepeating
		{
			get;
			private set;
		}
		public Reg32T<StartArbBlockRamAddrBF> StartArbBlockRamAddr
		{
			get;
			private set;
		}
		public Reg32T<StopArbBlockRamAddrBF> StopArbBlockRamAddr
		{
			get;
			private set;
		}
		public Reg32T<DisableInfiniteLoopingBF> DisableInfiniteLooping
		{
			get;
			private set;
		}
		public Reg32T<NoiseGainBF> NoiseGain
		{
			get;
			private set;
		}
		public Reg32T<InputSignalGainBF> InputSignalGain
		{
			get;
			private set;
		}
		public Reg32T<NoiseSeedNormalBF> NoiseSeedNormal
		{
			get;
			private set;
		}
		public Reg32T<ChannelFilterControlBF> ChannelFilterControl
		{
			get;
			private set;
		}
		public Reg32T<ChannelFilterWriteReBF> ChannelFilterWriteRe
		{
			get;
			private set;
		}
		public Reg32T<ChannelFilterWriteImBF> ChannelFilterWriteIm
		{
			get;
			private set;
		}
		public Reg32T<CoarseTimeStepBF> CoarseTimeStep
		{
			get;
			private set;
		}
		public Reg32T<FineTimeStepBF> FineTimeStep
		{
			get;
			private set;
		}
		public Reg32T<FineTimeModulusBF> FineTimeModulus
		{
			get;
			private set;
		}
		public Reg32T<NcoCoarsePhaseStepBF> NcoCoarsePhaseStep
		{
			get;
			private set;
		}
		public Reg32T<NcoFinePhaseStepBF> NcoFinePhaseStep
		{
			get;
			private set;
		}
		public Reg32T<NcoFinePhaseModulusBF> NcoFinePhaseModulus
		{
			get;
			private set;
		}
		public Reg32T<CorrectionFilterControlBF> CorrectionFilterControl
		{
			get;
			private set;
		}
		public Reg32T<CorrectionFilterWriteReBF> CorrectionFilterWriteRe
		{
			get;
			private set;
		}
		public Reg32T<CorrectionFilterWriteImBF> CorrectionFilterWriteIm
		{
			get;
			private set;
		}
		public Reg32T<ArbPlaybackDurationBF> ArbPlaybackDuration
		{
			get;
			private set;
		}
		public Reg32T<SourceStateMachineControlBF> SourceStateMachineControl
		{
			get;
			private set;
		}
		public Reg32T<ArmConfigBF> ArmConfig
		{
			get;
			private set;
		}
		public Reg32T<TriggerConfigBF> TriggerConfig
		{
			get;
			private set;
		}
		public Reg32T<PauseConfigBF> PauseConfig
		{
			get;
			private set;
		}
		public Reg32T<StopConfigBF> StopConfig
		{
			get;
			private set;
		}
		public Reg32T<DacConstantBF> DacConstant
		{
			get;
			private set;
		}
		public Reg32T<TriggerDelayBF> TriggerDelay
		{
			get;
			private set;
		}
		public Reg32T<TriggerHoldOffBF> TriggerHoldOff
		{
			get;
			private set;
		}
		public Reg32T<AutoTriggerTimeBF> AutoTriggerTime
		{
			get;
			private set;
		}
		public Reg32T<IGainBF> IGain
		{
			get;
			private set;
		}
		public Reg32T<QGainBF> QGain
		{
			get;
			private set;
		}
		public Reg32T<PowerServoLogGainBF> PowerServoLogGain
		{
			get;
			private set;
		}
		public Reg32T<PowerServoCurrentLogGainBF> PowerServoCurrentLogGain
		{
			get;
			private set;
		}
		public Reg32T<PowerServoMinLogGainBF> PowerServoMinLogGain
		{
			get;
			private set;
		}
		public Reg32T<PowerServoMaxLogGainBF> PowerServoMaxLogGain
		{
			get;
			private set;
		}
		public Reg32T<IOffsetBF> IOffset
		{
			get;
			private set;
		}
		public Reg32T<QOffsetBF> QOffset
		{
			get;
			private set;
		}
		public Reg32T<IQGainBF> IQGain
		{
			get;
			private set;
		}
		public Reg32T<InputDataCounterBF> InputDataCounter
		{
			get;
			private set;
		}
		public Reg32T<OutputDataCounterBF> OutputDataCounter
		{
			get;
			private set;
		}
		public Reg32T<CorrectionFilterCoefficientMemoryBF> CorrectionFilterCoefficientMemory
		{
			get;
			private set;
		}
		public Reg32T<ArbBlockRamIqDataBF> ArbBlockRamIqData
		{
			get;
			private set;
		}
		public Reg32T<ArbBlockRamUserMarksBF> ArbBlockRamUserMarks
		{
			get;
			private set;
		}
		#endregion Register Accessors

		/// <summary>
		/// Creates the device register set (typed registers). Uses the 'default' BAR
		/// (which is normally specified in the register spreadsheet).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		public SourceDspRegisterSet( IRegManager manager, IInstrument module, string groupName )
			: this( manager, module, groupName, (int)BaseAddress.SourceDsp0, /*barIndex=*/0 )
		{
		}
		/// <summary>
		/// Creates the device register set (typed registers). Uses the 'default' BAR
		/// (which is normally specified in the register spreadsheet).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		/// <param name="registerSetOffset">an offset added to all register offsets</param>
		public SourceDspRegisterSet( IRegManager manager, IInstrument module, string groupName, int registerSetOffset )
			: this( manager, module, groupName, registerSetOffset, /*barIndex=*/0 )
		{
		}
		/// <summary>
		/// Creates the device register set (typed registers).
		/// Note that the BAR and offset can be specified by the caller so the same RegisterSet
		/// class can be used to define multiple unique RegisterSet instances (different offset
		/// and or BAR).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		/// <param name="registerSetOffset">an offset added to all register offsets</param>
		/// <param name="barIndex">the BAR to use</param>
		public SourceDspRegisterSet( IRegManager manager, IInstrument module, string groupName, int registerSetOffset, int barIndex )
		{
			// Create the factory
			RegFactory regFactory = new RegFactory( registerSetOffset, module, Reg32.ConstructReg );

			// Determine which IRegDriver (determines default BAR)
			IRegDriver regDriver = ( barIndex >= module.RegDrivers.Length ) ? null : module.RegDrivers[ barIndex ];
			if( regDriver == null )
			{
				throw new InternalApplicationException( "SourceDspRegisterSet requires RegDriver for BAR" + barIndex );
			}

			// Create the register definitions 
			Registers = regFactory.CreateRegArray(
				mRegisterDefinitions,
				typeof( SourceDspRegister ),
				regDriver,
				module.Name );

			regFactory.CreateBitFields( mBitFieldDefinitions, Registers, module.Name, string.Empty );

			if( manager != null )
			{
				// Adding as a group creates an IDirtyBit and attaches to each register
				manager.AddGroup( groupName, this );
			}
			Event = new Reg32T<EventBF>((Reg32)Registers[(Int32)SourceDspRegister.Event]);
			InterruptMask = new Reg32T<EventBF>((Reg32)Registers[(Int32)SourceDspRegister.InterruptMask]);
			InterruptEvent = new Reg32T<EventBF>((Reg32)Registers[(Int32)SourceDspRegister.InterruptEvent]);
			InterruptMaskSet = new Reg32T<EventBF>((Reg32)Registers[(Int32)SourceDspRegister.InterruptMaskSet]);
			InterruptMaskClear = new Reg32T<EventBF>((Reg32)Registers[(Int32)SourceDspRegister.InterruptMaskClear]);
			Command = new Reg32T<CommandBF>((Reg32)Registers[(Int32)SourceDspRegister.Command]);
			SourceDspEnables = new Reg32T<SourceDspEnablesBF>((Reg32)Registers[ (Int32)SourceDspRegister.SourceDspEnables ]);
			InputFifoConfig = new Reg32T<InputFifoConfigBF>((Reg32)Registers[ (Int32)SourceDspRegister.InputFifoConfig ]);
			NumArbSamplesBeforeRepeating = new Reg32T<NumArbSamplesBeforeRepeatingBF>((Reg32)Registers[ (Int32)SourceDspRegister.NumArbSamplesBeforeRepeating ]);
			StartArbBlockRamAddr = new Reg32T<StartArbBlockRamAddrBF>((Reg32)Registers[ (Int32)SourceDspRegister.StartArbBlockRamAddr ]);
			StopArbBlockRamAddr = new Reg32T<StopArbBlockRamAddrBF>((Reg32)Registers[ (Int32)SourceDspRegister.StopArbBlockRamAddr ]);
			DisableInfiniteLooping = new Reg32T<DisableInfiniteLoopingBF>((Reg32)Registers[ (Int32)SourceDspRegister.DisableInfiniteLooping ]);
			NoiseGain = new Reg32T<NoiseGainBF>((Reg32)Registers[ (Int32)SourceDspRegister.NoiseGain ]);
			InputSignalGain = new Reg32T<InputSignalGainBF>((Reg32)Registers[ (Int32)SourceDspRegister.InputSignalGain ]);
			NoiseSeedNormal = new Reg32T<NoiseSeedNormalBF>((Reg32)Registers[ (Int32)SourceDspRegister.NoiseSeedNormal ]);
			ChannelFilterControl = new Reg32T<ChannelFilterControlBF>((Reg32)Registers[ (Int32)SourceDspRegister.ChannelFilterControl ]);
			ChannelFilterWriteRe = new Reg32T<ChannelFilterWriteReBF>((Reg32)Registers[ (Int32)SourceDspRegister.ChannelFilterWriteRe ]);
			ChannelFilterWriteIm = new Reg32T<ChannelFilterWriteImBF>((Reg32)Registers[ (Int32)SourceDspRegister.ChannelFilterWriteIm ]);
			CoarseTimeStep = new Reg32T<CoarseTimeStepBF>((Reg32)Registers[ (Int32)SourceDspRegister.CoarseTimeStep ]);
			FineTimeStep = new Reg32T<FineTimeStepBF>((Reg32)Registers[ (Int32)SourceDspRegister.FineTimeStep ]);
			FineTimeModulus = new Reg32T<FineTimeModulusBF>((Reg32)Registers[ (Int32)SourceDspRegister.FineTimeModulus ]);
			NcoCoarsePhaseStep = new Reg32T<NcoCoarsePhaseStepBF>((Reg32)Registers[ (Int32)SourceDspRegister.NcoCoarsePhaseStep ]);
			NcoFinePhaseStep = new Reg32T<NcoFinePhaseStepBF>((Reg32)Registers[ (Int32)SourceDspRegister.NcoFinePhaseStep ]);
			NcoFinePhaseModulus = new Reg32T<NcoFinePhaseModulusBF>((Reg32)Registers[ (Int32)SourceDspRegister.NcoFinePhaseModulus ]);
			CorrectionFilterControl = new Reg32T<CorrectionFilterControlBF>((Reg32)Registers[ (Int32)SourceDspRegister.CorrectionFilterControl ]);
			CorrectionFilterWriteRe = new Reg32T<CorrectionFilterWriteReBF>((Reg32)Registers[ (Int32)SourceDspRegister.CorrectionFilterWriteRe ]);
			CorrectionFilterWriteIm = new Reg32T<CorrectionFilterWriteImBF>((Reg32)Registers[ (Int32)SourceDspRegister.CorrectionFilterWriteIm ]);
			ArbPlaybackDuration = new Reg32T<ArbPlaybackDurationBF>((Reg32)Registers[ (Int32)SourceDspRegister.ArbPlaybackDuration ]);
			SourceStateMachineControl = new Reg32T<SourceStateMachineControlBF>((Reg32)Registers[ (Int32)SourceDspRegister.SourceStateMachineControl ]);
			ArmConfig = new Reg32T<ArmConfigBF>((Reg32)Registers[ (Int32)SourceDspRegister.ArmConfig ]);
			TriggerConfig = new Reg32T<TriggerConfigBF>((Reg32)Registers[ (Int32)SourceDspRegister.TriggerConfig ]);
			PauseConfig = new Reg32T<PauseConfigBF>((Reg32)Registers[ (Int32)SourceDspRegister.PauseConfig ]);
			StopConfig = new Reg32T<StopConfigBF>((Reg32)Registers[ (Int32)SourceDspRegister.StopConfig ]);
			DacConstant = new Reg32T<DacConstantBF>((Reg32)Registers[ (Int32)SourceDspRegister.DacConstant ]);
			TriggerDelay = new Reg32T<TriggerDelayBF>((Reg32)Registers[ (Int32)SourceDspRegister.TriggerDelay ]);
			TriggerHoldOff = new Reg32T<TriggerHoldOffBF>((Reg32)Registers[ (Int32)SourceDspRegister.TriggerHoldOff ]);
			AutoTriggerTime = new Reg32T<AutoTriggerTimeBF>((Reg32)Registers[ (Int32)SourceDspRegister.AutoTriggerTime ]);
			IGain = new Reg32T<IGainBF>((Reg32)Registers[ (Int32)SourceDspRegister.IGain ]);
			QGain = new Reg32T<QGainBF>((Reg32)Registers[ (Int32)SourceDspRegister.QGain ]);
			PowerServoLogGain = new Reg32T<PowerServoLogGainBF>((Reg32)Registers[ (Int32)SourceDspRegister.PowerServoLogGain ]);
			PowerServoCurrentLogGain = new Reg32T<PowerServoCurrentLogGainBF>((Reg32)Registers[ (Int32)SourceDspRegister.PowerServoCurrentLogGain ]);
			PowerServoMinLogGain = new Reg32T<PowerServoMinLogGainBF>((Reg32)Registers[ (Int32)SourceDspRegister.PowerServoMinLogGain ]);
			PowerServoMaxLogGain = new Reg32T<PowerServoMaxLogGainBF>((Reg32)Registers[ (Int32)SourceDspRegister.PowerServoMaxLogGain ]);
			IOffset = new Reg32T<IOffsetBF>((Reg32)Registers[ (Int32)SourceDspRegister.IOffset ]);
			QOffset = new Reg32T<QOffsetBF>((Reg32)Registers[ (Int32)SourceDspRegister.QOffset ]);
			IQGain = new Reg32T<IQGainBF>((Reg32)Registers[ (Int32)SourceDspRegister.IQGain ]);
			InputDataCounter = new Reg32T<InputDataCounterBF>((Reg32)Registers[ (Int32)SourceDspRegister.InputDataCounter ]);
			OutputDataCounter = new Reg32T<OutputDataCounterBF>((Reg32)Registers[ (Int32)SourceDspRegister.OutputDataCounter ]);
			CorrectionFilterCoefficientMemory = new Reg32T<CorrectionFilterCoefficientMemoryBF>((Reg32)Registers[ (Int32)SourceDspRegister.CorrectionFilterCoefficientMemory ]);
			ArbBlockRamIqData = new Reg32T<ArbBlockRamIqDataBF>((Reg32)Registers[ (Int32)SourceDspRegister.ArbBlockRamIqData ]);
			ArbBlockRamUserMarks = new Reg32T<ArbBlockRamUserMarksBF>((Reg32)Registers[ (Int32)SourceDspRegister.ArbBlockRamUserMarks ]);
		}

		/// <summary>
		/// Sets the initial values for the registers. Does not apply the values (write to HW).
		/// </summary>
		public override void SetInitialValues()
		{
			Event.Field( EventBF.DspOverflowOccurred ).Value = 0;
			Event.Field( EventBF.DacUnderflow ).Value = 0;
			Event.Field( EventBF.EnteredIdleState ).Value = 0;
			Event.Field( EventBF.EnteredArmingState ).Value = 0;
			Event.Field( EventBF.EnteredTriggerState ).Value = 0;
			Event.Field( EventBF.EnteredRunState ).Value = 0;
			Event.Field( EventBF.UserMark0 ).Value = 0;
			Event.Field( EventBF.UserMark1 ).Value = 0;
			Event.Field( EventBF.UserMark2 ).Value = 0;
			Event.Field( EventBF.UserMark3 ).Value = 0;
			InterruptMaskSet.Value = 0;
			InterruptMaskClear.Value = 0;
			Command.Field( CommandBF.StartStrobe ).Value = 0;
			Command.Field( CommandBF.ArmStrobe ).Value = 0;
			Command.Field( CommandBF.SoftwareTriggerStrobe ).Value = 0;
			Command.Field( CommandBF.StopStrobe ).Value = 0;
			Command.Field( CommandBF.ResetRegistersStrobe ).Value = 0;
			Command.Field( CommandBF.PauseStrobe ).Value = 0;
			Command.Field( CommandBF.ReseedNoiseStrobe ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableSourceInputFifo ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableArbBlockRam ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableNoiseGenerator ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableChannelFilter ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableArbitraryInterpolator ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableInterpolateBy4 ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableNcoAndMixer ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableCorrectionFilter ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableSourceStateMachine ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnableVariableGainAndOffset ).Value = 0;
			SourceDspEnables.Field( SourceDspEnablesBF.EnablePackAs16Bits ).Value = 0;
			InputFifoConfig.Field( InputFifoConfigBF.UseLsbsAsUserMarks ).Value = 0;
			InputFifoConfig.Field( InputFifoConfigBF.NumSamplesPerClock ).Value = 0;
			InputFifoConfig.Field( InputFifoConfigBF.InputPackingSize ).Value = 0;
			NumArbSamplesBeforeRepeating.Value = 0;
			StartArbBlockRamAddr.Field( StartArbBlockRamAddrBF.Address ).Value = 0;
			StopArbBlockRamAddr.Field( StopArbBlockRamAddrBF.Address ).Value = 0;
			DisableInfiniteLooping.Field( DisableInfiniteLoopingBF.Disable ).Value = 0;
			NoiseGain.Field( NoiseGainBF.Gain ).Value = 0;
			InputSignalGain.Field( InputSignalGainBF.Gain ).Value = 65536;
			NoiseSeedNormal.Value = 0;
			ChannelFilterControl.Field( ChannelFilterControlBF.DspSetSelect ).Value = 0;
			ChannelFilterControl.Field( ChannelFilterControlBF.CtrlWriteEnable ).Value = 0;
			ChannelFilterControl.Field( ChannelFilterControlBF.CtrlSetSelect ).Value = 0;
			ChannelFilterControl.Field( ChannelFilterControlBF.CtrlReadBackModeEnabled ).Value = 0;
			ChannelFilterControl.Field( ChannelFilterControlBF.CtrlAddress ).Value = 0;
			ChannelFilterWriteRe.Field( ChannelFilterWriteReBF.Real ).Value = 0;
			ChannelFilterWriteIm.Field( ChannelFilterWriteImBF.Imag ).Value = 0;
			CoarseTimeStep.Field( CoarseTimeStepBF.CoarseTimeStep ).Value = -8388608;
			FineTimeStep.Field( FineTimeStepBF.FineTimeStep ).Value = 0;
			FineTimeModulus.Field( FineTimeModulusBF.FineTimeModulus ).Value = -5058467;
			NcoCoarsePhaseStep.Field( NcoCoarsePhaseStepBF.NcoCoarsePhaseStep ).Value = 0;
			NcoFinePhaseStep.Field( NcoFinePhaseStepBF.NcoFinePhaseStep ).Value = 0;
			NcoFinePhaseModulus.Field( NcoFinePhaseModulusBF.NcoFinePhaseModulus ).Value = -5058467;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.DspSetSelect ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlWriteEnable ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlSetSelect ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlMatrixElementSelect ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlReadBackModeEnabled ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlAddress ).Value = 0;
			CorrectionFilterWriteRe.Field( CorrectionFilterWriteReBF.Real ).Value = 0;
			CorrectionFilterWriteIm.Field( CorrectionFilterWriteImBF.Imag ).Value = 0;
			ArbPlaybackDuration.Value = 0;
			SourceStateMachineControl.Field( SourceStateMachineControlBF.HoldLastSample ).Value = 0;
			ArmConfig.Field( ArmConfigBF.ArmSource ).Value = 0;
			ArmConfig.Field( ArmConfigBF.ArmUserMark ).Value = 0;
			TriggerConfig.Field( TriggerConfigBF.TriggerSource ).Value = 0;
			TriggerConfig.Field( TriggerConfigBF.TriggerUserMark ).Value = 0;
			PauseConfig.Field( PauseConfigBF.PauseSource ).Value = 0;
			PauseConfig.Field( PauseConfigBF.PauseUserMark ).Value = 0;
			StopConfig.Field( StopConfigBF.StopSource ).Value = 0;
			StopConfig.Field( StopConfigBF.StopUserMark ).Value = 0;
			DacConstant.Field( DacConstantBF.IDacConstant ).Value = 0;
			DacConstant.Field( DacConstantBF.QDacConstant ).Value = 0;
			TriggerDelay.Value = 0;
			TriggerHoldOff.Value = 0;
			AutoTriggerTime.Value = 0;
			IGain.Field( IGainBF.IGain ).Value = 65536;
			QGain.Field( QGainBF.QGain ).Value = 65536;
			PowerServoLogGain.Field( PowerServoLogGainBF.PowerServoLogGain ).Value = 0;
			PowerServoMinLogGain.Field( PowerServoMinLogGainBF.PowerServoMinLogGain ).Value = 8192;
			PowerServoMaxLogGain.Field( PowerServoMaxLogGainBF.PowerServoMaxLogGain ).Value = 8191;
			IOffset.Value = 0;
			QOffset.Value = 0;
			IQGain.Field( IQGainBF.IQGain ).Value = 262144;
			ArbBlockRamIqData.Value = 0;
			ArbBlockRamUserMarks.Field( ArbBlockRamUserMarksBF.UserMarks ).Value = 0;
		}
	}

	#endregion RegisterSets
}
