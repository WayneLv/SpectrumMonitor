using System;
using InstrumentDriver.Core;
using InstrumentDriver.Core.Register;
using InstrumentDriver.Core.Interfaces;
using InstrumentDriver.Core.Utility;

namespace InstrumentDriver.NewInstrument
{

	// DO NOT EDIT THIS FILE.
	// This file was generated on 2020/1/26 23:08:28 from C:\TEMP\ReceiverDspRegisterSet.xlsx
	// by D:\Programs\MyRegisterFileTool\RegisterFileTool\bin\Debug\MyRegisterFileTool.exe version 1.5.5.0


	#region RegisterSets
	public class ReceiverDspRegisterSet : AbstractRegisterSet
	{

		#region Base Address(es) / Group Offset(s)

		// These are the base addresses (group offsets) defined by the register spreadsheet.
		// The client code will normally instantiate an instance of the register set for each.
		[System.Reflection.Obfuscation( Exclude = true )]
		public enum BaseAddress
		{
			ReceiverDsp0 = 0x0,
		}

		#endregion Base Address(es)

		#region ReceiverRegisters Register enums

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ReceiverDspRegister
		{
			Event, // 0x60000 When an event occurs, its corresponding bit in the event register becomes set and stays set until explicitly cleared.  A write to the event register will clear all event bits corresponding to a ‘1’ in the write value.
			InterruptMask, // 0x60004 Whenever the bitwise AND of the Event register and InterruptMask results in a bit change from 0 to 1, an interrupt message will be sent to the host controller (ie the PCIe root complex). Note that if an event bit had been set earlier but the corresponding interrupt mask bit had not been, then simply setting the mask bit to a 1 will cause an immediate interrupt message to be sent.  The InterruptMask bits are set and cleared with the InterruptMaskSet and InterruptMaskClear.
			InterruptEvent, // 0x60008 This register is the bitwise AND of Event and InterruptMask.
			InterruptMaskSet, // 0x60010 Writing this register will perform a bitwise OR with the InterruptMask, so any bit set in the InterruptMaskSet will get set in the InterruptMask.
			InterruptMaskClear, // 0x60014 Writing this register will perform a bitwise AND of the InterruptMask and the inverse of InterruptMaskClear, so any bits set in InterruptMaskClear will get cleared in the InterruptMask.
			Command, // 0x60018 This register provides a single location to invoke single-shot actions.  Only a single bit should be a 1 at a time, otherwise what happens is undefined.
			ReceiverDspEnables, // 0x6001c This register contains a bit field to enable or bypass each of the DSP blocks in the VXT 2 receiver DSP chain.  0 = bypass.  1 = enable.  The default value of 0 causes all receiver DSP blocks to be bypassed.
			InputFifoConfig, // 0x600c8 InputFifo configuration register
			InputMux, // 0x60020 0 = ADC data, 1 = Simulated IQ data, 2 = Ramp, 15=No Data
			RampRate, // 0x60024 
			SimIData, // 0x60028 Simulated I Data that will be sent to SimulationMux module whenever SimDataStrobe is written
			SimQData, // 0x6002c Simulated Q Data that will be sent to the SimulationMux module whenever SimDataStrobe is written
			SimTrigger, // 0x60030 Simulated trigger mark that will be sent to the SimulationMux module whenever SimDataStrobe is written.  1 = trigger, 0 = 0 no trigger
			TriggerModuleControl, // 0x60034 Not currently used
			AdcTriggerDelay, // 0x60038 Not currently used
			AdcDataDelay, // 0x6003c Not currently used
			IGain, // 0x60040 Signed 18-bit value representing a gain to apply to the I channel in the GainAndOffset module.  A value of 0x10000 represents unity gain.
			QGain, // 0x60044 Signed 18-bit value representing a gain to apply to the Q channel in the GainAndOffset module.  A value of 0x10000 (1.0) represents unity gain.  Setting this register to 0x30000 (-1.0) negates the Q input, which can be  used to effectively mirror the IQ spectrum.
			IOffset, // 0x60048 Signed 32-bit value representing a DC offset to apply to the I channel in the GainAndOffset module.
			QOffset, // 0x6004c Signed 32-bit value representing a DC offset to apply to the Q channel in the GainAndOffset module.
			WidebandMagnitudeTrigLevel, // 0x60050 This 31-bit unsigned register holds the wideband magnitude trigger level used when the TriggerSource=WidebandMagnitude.  A trigger is generated whenever the magnitude of the IQ data  ( sqrt(I^2 + Q^2) ) crosses this level in either a positive going direction or a negative going direction, depending on the setting of the TriggerSlope.
			Nco1CoarsePhaseStep, // 0x600e4 This register is used to set the coarse resolution of  NCO #1.   Nco1CoarsePhaseStep = (int)Math.Floor((1 << 24) * normalizedFreq), where normalizedFreq is between 0 and 1.
			Nco1FinePhaseStep, // 0x600e8 Used to set a finer resolution phase step than can be achieved by Nco1CoarsePhaseStep alone.  Nco1FinePhaseStep =(int)Math.Round((1 << 24) * (Nco1FinePhaseModulus + 1L) * normalizedFreq - Nco1CoarsePhaseStep * (Nco1FinePhaseModulus + 1L))
			Nco1FinePhaseModulus, // 0x600ec Used in conjunction with Nco1FinePhaseStep to achieve a finer resolution time step than can be achieved by Nco1CoarsePhaseStep alone.  It is recommended to set Nco1FinePhaseModulus = 5^10 - 1, which allows the NCO #1 to be set to any frequency that is a multiple of 1 Hz.
			CorrectionFilterControl, // 0x60054 
			CorrectionFilterWriteRe, // 0x60058 Real component of frequency domain coefficient to be written (signed 18 bits, 16 fractional bits).
			CorrectionFilterWriteIm, // 0x6005c Imaginary component of frequency domain coefficient to be written (signed 18 bits, 16 fractional bits).
			Nco2CoarsePhaseStep, // 0x60060 This register is used to set the coarse resolution of  NCO #2.   Nco2CoarsePhaseStep = (int)Math.Floor((1 << 24) * normalizedFreq), where normalizedFreq is between 0 and 1.
			Nco2FinePhaseStep, // 0x60064 Used to set a finer resolution phase step than can be achieved by Nco2CoarsePhaseStep alone.  Nco2FinePhaseStep =(int)Math.Round((1 << 24) * (Nco2FinePhaseModulus + 1L) * normalizedFreq - Nco2CoarsePhaseStep * (Nco2FinePhaseModulus + 1L))
			Nco2FinePhaseModulus, // 0x60068 Used in conjunction with Nco2FinePhaseStep to achieve a finer resolution time step than can be achieved by Nco2CoarsePhaseStep alone.  It is recommended to set Nco2FinePhaseModulus = 5^10 - 1, which allows the NCO #2 to be set to any frequency that is a multiple of 1 Hz.
			CoarseTimeStep, // 0x6006c This register is used to set the coarse resolution of the arbitrary resampler.   CoarseTimeStep = floor(2^24 / decimationFactor)
			FineTimeStep, // 0x60070 Used to set a finer resolution time step than can be achieved by CoarseTimeStep alone.  FineTimeStep = round( 2^24 * (FineTimeModulus + 1) / decimationFactor - CoarseTimeStep * (FineTimeModulus + 1))
			FineTimeModulus, // 0x60074 Used in conjunction with FineTimeStep to achieve a finer resolution time step than can be achieved by CoarseTimeStep alone.  It is recommended to set FineTimeModulus = 5^10 - 1, which allows the output sample rate from the ArbitraryDecimator to exactly achieve any rate that is a multiple of 1 Hz.
			ScaleShiftBits, // 0x60078 Used by the arbitrary decimator module to choose which bits to process in order to avoid fixed point math overflows.  ScaleShiftBits = (int)Math.Ceiling(Math.Log(decimationFactor) / Math.Log(2))
			ScaleFactor, // 0x6007c Used in conjunction with the ScaleShiftBits register to adjust the gain within the arbitrary decimator module.  While  ScaleShiftBits is used to adjust the gain to the nearest power of two, this register is used apply a fine grain gain between 1.0 and 2.0.  ScaleFactor = (int)Math.Floor(0x10000 * (double)(1 << ScaleShiftBits) / decimationFactor)
			ChannelFilterCoefficentRamSelect, // 0x60080 0 = use ChannelFilterCoefficientRam0, 1 = use ChannelFilterCoefficientRam1
			MagnitudeTrigLevel, // 0x60084 This 31-bit unsigned register holds the magnitude trigger level used when the TriggerSource=Magnitude.  A trigger is generated whenever the magnitude of the IQ data  ( sqrt(I^2 + Q^2) ) crosses this level in either a positive going direction or a negative going direction, depending on the setting of the TriggerSlope.
			OverlapFactor, // 0x6008c If overlapFactor = 0, then only 1 IQ sample is skipped ahead on each FFT, which means 1023 out of 1024 IQ samples will be the same (99.9% overlap).  If overlapFactor = 255, then 256 IQ samples are skipped ahead on each FFT, which means 768 out of 1024 IQ samples will be the same (75% overlap).  If overlapFactor = 1023, then 1024 IQ samples are skipped ahead on each FFT, which means 0% overlap.
			FftSizeLog2, // 0x60090 When processing frequency-domain data (i.e. the Fft is enabled), this register determines the log2 FFT size.  Valid range 3 to 11, which gives an 8 tap to 2048 tap FFT, respectively.  When doing time-domain processing, set this register to 0.
			DetectorDecimationFactor, // 0x60094 For frequency-domain data, this is the number of FFTs to combine in each detector frame.  Each FFT bin is effectively running its own set of detectors on just that FFT bin.  For time-domain data, this is the number of IQ samples to combine together per detector output.  Be sure to set FftSizeLog2 to 0 when detecting time-domain data.  Note that the Detector module expects log data going into it, which means that the ComplexMagnitude and Logger modules must be enabled whenever using the Detectors module.
			DetectorOffset, // 0x60098 Offset to apply in the Detector module to adjust the dB amplitude coming out of the detectors.  This register value is an 18-bit signed value where each LSB represents 0.0025 dB.
			ChannelPowerOffset, // 0x600f0 Offset to apply in the ChannelPower module to adjust the measured dB channel power.  This register value is a 16-bit unsigned value where each LSB represents 0.0025 dB.  Typically, the FFT window shape determines the value written to this register.
			ChannelPowerShapeRamBankSelect, // 0x600f4 There are 5 channel power shape RAMs used by the ChannelPower measurement.  This register determines which RAM bank is mapped to the address range 0xe000 to 0xffff.  This register also determines which of the 5 channel power measurement results is returned by ChannelPowerMeasurement.
			ChannelPowerMeasurement, // 0x600f8 Returns the channel power measurement result.  Full scale is 0 and each LSB represents -0.0025 dB.  The ChannelPowerShapeRamBankSelect selects which of the 5 channel power measurement results to return.
			PowerServoMinTargetPower, // 0x60100 Unsigned 16-bit log value where full scale is 0 and each LSB represents -0.0025 dB.  This value represents the minimum power level relative to full scale  that the PowerServo module will consider as the exit criteria to the power servo loop.
			PowerServoMaxTargetPower, // 0x60104 Unsigned 16-bit log value where full scale is 0 and each LSB represents -0.0025 dB.  This value represents the maximum power level relative to full scale  that the PowerServo module will consider as the exit criteria to the power servo loop.
			PowerServoMaxLoops, // 0x60108 Unsigned 8-bit value representing the maximum number of loops that the PowerServo will iterate through to try to achieve the target power before failing.
			PowerServoLoopCount, // 0x6010c Unsigned 8-bit value indicating the current loop count of the power servo.
			TraceConfig, // 0x6009c Configures the trace state and detectors for each of the 4 traces in the Trace module
			TraceAverageCount, // 0x600a0 Trace average count, which only applies when the trace state is set to RmsAverage
			IScaleFactor, // 0x600a4 IEEE 754 32-bit floating point number to scale the I Data (only applies when enableComplexScaleDouble == 1)
			QScaleFactor, // 0x600a8 IEEE 754 32-bit floating point number to scale the Q Data (only applies when enableComplexScaleDouble == 1)
			MeasControl, // 0x600ac 
			BlockSize, // 0x600b0 Number of IQ samples per block to capture.  Always set BlockSize > 0.  If EnableAccumulate is true, then BlockSize must be set to a multiple of 4 between 32 and 8192.  If BlocksPerCapture > 1,  then BlockSize must be less than 2^16.
			BlocksPerCapture, // 0x600b4 Specifies the number of blocks to acquire in a measurement.  A measurement consists of the number of blocks specified by this register, each containing the number of IQ samples specified by the BlockSize register.  Each block requires a new trigger to initiate the capture for that block, except when the TriggerSource is FreeRun.  Always set BlocksPerCapture > 0.
			TriggerControl, // 0x600b8 Trigger configuration register
			TriggerDelay, // 0x600bc This 32-bit signed value determines the number of IQ sample periods  between a trigger event and the actual collection of a block of data. Positive values delay data collection by the indicated number of samples. Negative values provide pre-trigger offsets. Negative values are valid only when BlocksPerCapture=1  and the EnablePreFftTrigger=0.
			TriggerHoldOff, // 0x600c0 This 32-bit unsigned register determines the Trigger Hold-Off in terms of IQ samples. If TriggerHoldOff is set to zero, it is equivalent to setting the Trigger Hold-Off Type to TriggerHoldOffType::None. Normal Trigger Hold-Off must be greater than or equal to 50 ns. The Trigger Hold-Off modes are specified by the TriggerControl register and documented above. This register only applies when BlocksPerCapture > 1 or when Continuous == 1.
			AutoTriggerTime, // 0x600c4 This register determines how much time (in number of IQ samples) elapses before a trigger is automatically generated.  If a trigger signal is not received before the specified auto trigger time, then the measurement state machine will automatically transition from the Trigger to Run state. Setting this register to 0 disables auto triggering. Setting this register > 0 will cause a counter to count that many IQ samples  (after decimation) before automatically generating the trigger.
			SampleIndexOfTriggerPosition, // 0x600cc When a negative trigger delay is used, this read-only register returns the IQ sample index within capture memory where the trigger occurred.  Always set the WriteLength of the AdcDramWriter to a power of two when using a negative trigger delay.  Use the following equation to determine the sample index within capture memory where the trigger occurred: SampleIndexOfTriggerPosition % WriteLength
			RoundingSize, // 0x600d0 Rounds the I and Q data to fewer bits (which is a good idea to do if packing the data).  The most significant bits are kept and the least significant bits are zeroed-out.
			PackingSize, // 0x600d4 Determines how the IQ data is packed before sending it to capture RAM.
			Accumulate, // 0x600d8 Control for doing vector data block averaging in the fast capture RAM.  Block averaging can be either done in the time domain (when EnableFft is false) or in the frequency domain (when EnableFft is true).
			RathDebug0, // 0x600dc Experimental debugging register
			RathDebug1, // 0x600e0 Experimental debugging register
			ChannelFilterCoefficientRam0, // 0x60800 128 Frequency-domain complex-valued filter taps (real in addresses ending in 0x0 or 0x8, imaginary in addresses ending in 0x4 or 0xc). Full Scale = 2^22
			ChannelFilterCoefficientRam1, // 0x60c00 128 Frequency-domain complex-valued filter taps (real in addresses ending in 0x0 or 0x8, imaginary in addresses ending in 0x4 or 0xc). Full Scale = 2^22
			CorrectionFilterCoefficientMemoryWindow, // 0x61000 Correction Filter Coefficient Memory Window span base address. Access location within CorrectionFilterCoefficientMemoryWindow span is specified by { CorrectionFilterControl.CtrlSetSelect, CorrectionFilterControl.CtrlMatrixElementSelect, s_axi_awaddr[log2FftLength:0] } because out of address space to map the entire Coefficient Memory. Each address accesses 18-bit 2's complement FFT coefficient with real components at even addresses and imaginary components at odd addresses. Must write real component first followed by imaginary component!
			FftWindowRam, // 0x62000 2048 FFT window coefficients.  Each address is an 18-bit 2's complement coefficient representing the FFT window shape.
			PositivePeakDetectorRam, // 0x64000 Real-time positive peak detector.
			NegativePeakDetectorRam, // 0x66000 Real-time negative peak detector.
			SampleDetectorRam, // 0x68000 Real-time sample detector.
			NormalDetectorRam, // 0x6a000 Real-time normal detector.
			RmsAverageDetectorRam, // 0x6c000 Real-time RMS average detector.
			ChannelPowerShapeRam, // 0x6e000 2048 coefficients.  Each address is a 16-bit log value of the channel shape where the LSB represents -0.0025 dB.  A value of 0 represents unity gain, whereas 0xffff is effectively zero gain.  A -3.02 dB gain would be represented by the value 0x04b8.  There are 5 banks of the ChannelPowerShapeRam.  The bank is selected by the ChannelPowerShapeRamBankSelect register.
			FastCaptureRam, // 0x70000 Block average RAM made from block RAMs within the FPGA.
		}

		/// <summary>
		/// Register offset from original register definition (excludes 'Base').
		/// </summary>
		/// <remarks>
		/// The actual/runtime register offset is affected by parameters passed to the
		/// register factory and may not match the values defined here.
		/// </remarks>
		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ReceiverDspRegisterOffsets
		{
			Event = 0x0000, // When an event occurs, its corresponding bit in the event register becomes set and stays set until explicitly cleared.  A write to the event register will clear all event bits corresponding to a ‘1’ in the write value.
			InterruptMask = 0x0004, // Whenever the bitwise AND of the Event register and InterruptMask results in a bit change from 0 to 1, an interrupt message will be sent to the host controller (ie the PCIe root complex). Note that if an event bit had been set earlier but the corresponding interrupt mask bit had not been, then simply setting the mask bit to a 1 will cause an immediate interrupt message to be sent.  The InterruptMask bits are set and cleared with the InterruptMaskSet and InterruptMaskClear.
			InterruptEvent = 0x0008, // This register is the bitwise AND of Event and InterruptMask.
			InterruptMaskSet = 0x0010, // Writing this register will perform a bitwise OR with the InterruptMask, so any bit set in the InterruptMaskSet will get set in the InterruptMask.
			InterruptMaskClear = 0x0014, // Writing this register will perform a bitwise AND of the InterruptMask and the inverse of InterruptMaskClear, so any bits set in InterruptMaskClear will get cleared in the InterruptMask.
			Command = 0x0018, // This register provides a single location to invoke single-shot actions.  Only a single bit should be a 1 at a time, otherwise what happens is undefined.
			ReceiverDspEnables = 0x001c, // This register contains a bit field to enable or bypass each of the DSP blocks in the VXT 2 receiver DSP chain.  0 = bypass.  1 = enable.  The default value of 0 causes all receiver DSP blocks to be bypassed.
			InputFifoConfig = 0x00c8, // InputFifo configuration register
			InputMux = 0x0020, // 0 = ADC data, 1 = Simulated IQ data, 2 = Ramp, 15=No Data
			RampRate = 0x0024, // 
			SimIData = 0x0028, // Simulated I Data that will be sent to SimulationMux module whenever SimDataStrobe is written
			SimQData = 0x002c, // Simulated Q Data that will be sent to the SimulationMux module whenever SimDataStrobe is written
			SimTrigger = 0x0030, // Simulated trigger mark that will be sent to the SimulationMux module whenever SimDataStrobe is written.  1 = trigger, 0 = 0 no trigger
			TriggerModuleControl = 0x0034, // Not currently used
			AdcTriggerDelay = 0x0038, // Not currently used
			AdcDataDelay = 0x003c, // Not currently used
			IGain = 0x0040, // Signed 18-bit value representing a gain to apply to the I channel in the GainAndOffset module.  A value of 0x10000 represents unity gain.
			QGain = 0x0044, // Signed 18-bit value representing a gain to apply to the Q channel in the GainAndOffset module.  A value of 0x10000 (1.0) represents unity gain.  Setting this register to 0x30000 (-1.0) negates the Q input, which can be  used to effectively mirror the IQ spectrum.
			IOffset = 0x0048, // Signed 32-bit value representing a DC offset to apply to the I channel in the GainAndOffset module.
			QOffset = 0x004c, // Signed 32-bit value representing a DC offset to apply to the Q channel in the GainAndOffset module.
			WidebandMagnitudeTrigLevel = 0x0050, // This 31-bit unsigned register holds the wideband magnitude trigger level used when the TriggerSource=WidebandMagnitude.  A trigger is generated whenever the magnitude of the IQ data  ( sqrt(I^2 + Q^2) ) crosses this level in either a positive going direction or a negative going direction, depending on the setting of the TriggerSlope.
			Nco1CoarsePhaseStep = 0x00e4, // This register is used to set the coarse resolution of  NCO #1.   Nco1CoarsePhaseStep = (int)Math.Floor((1 << 24) * normalizedFreq), where normalizedFreq is between 0 and 1.
			Nco1FinePhaseStep = 0x00e8, // Used to set a finer resolution phase step than can be achieved by Nco1CoarsePhaseStep alone.  Nco1FinePhaseStep =(int)Math.Round((1 << 24) * (Nco1FinePhaseModulus + 1L) * normalizedFreq - Nco1CoarsePhaseStep * (Nco1FinePhaseModulus + 1L))
			Nco1FinePhaseModulus = 0x00ec, // Used in conjunction with Nco1FinePhaseStep to achieve a finer resolution time step than can be achieved by Nco1CoarsePhaseStep alone.  It is recommended to set Nco1FinePhaseModulus = 5^10 - 1, which allows the NCO #1 to be set to any frequency that is a multiple of 1 Hz.
			CorrectionFilterControl = 0x0054, // 
			CorrectionFilterWriteRe = 0x0058, // Real component of frequency domain coefficient to be written (signed 18 bits, 16 fractional bits).
			CorrectionFilterWriteIm = 0x005c, // Imaginary component of frequency domain coefficient to be written (signed 18 bits, 16 fractional bits).
			Nco2CoarsePhaseStep = 0x0060, // This register is used to set the coarse resolution of  NCO #2.   Nco2CoarsePhaseStep = (int)Math.Floor((1 << 24) * normalizedFreq), where normalizedFreq is between 0 and 1.
			Nco2FinePhaseStep = 0x0064, // Used to set a finer resolution phase step than can be achieved by Nco2CoarsePhaseStep alone.  Nco2FinePhaseStep =(int)Math.Round((1 << 24) * (Nco2FinePhaseModulus + 1L) * normalizedFreq - Nco2CoarsePhaseStep * (Nco2FinePhaseModulus + 1L))
			Nco2FinePhaseModulus = 0x0068, // Used in conjunction with Nco2FinePhaseStep to achieve a finer resolution time step than can be achieved by Nco2CoarsePhaseStep alone.  It is recommended to set Nco2FinePhaseModulus = 5^10 - 1, which allows the NCO #2 to be set to any frequency that is a multiple of 1 Hz.
			CoarseTimeStep = 0x006c, // This register is used to set the coarse resolution of the arbitrary resampler.   CoarseTimeStep = floor(2^24 / decimationFactor)
			FineTimeStep = 0x0070, // Used to set a finer resolution time step than can be achieved by CoarseTimeStep alone.  FineTimeStep = round( 2^24 * (FineTimeModulus + 1) / decimationFactor - CoarseTimeStep * (FineTimeModulus + 1))
			FineTimeModulus = 0x0074, // Used in conjunction with FineTimeStep to achieve a finer resolution time step than can be achieved by CoarseTimeStep alone.  It is recommended to set FineTimeModulus = 5^10 - 1, which allows the output sample rate from the ArbitraryDecimator to exactly achieve any rate that is a multiple of 1 Hz.
			ScaleShiftBits = 0x0078, // Used by the arbitrary decimator module to choose which bits to process in order to avoid fixed point math overflows.  ScaleShiftBits = (int)Math.Ceiling(Math.Log(decimationFactor) / Math.Log(2))
			ScaleFactor = 0x007c, // Used in conjunction with the ScaleShiftBits register to adjust the gain within the arbitrary decimator module.  While  ScaleShiftBits is used to adjust the gain to the nearest power of two, this register is used apply a fine grain gain between 1.0 and 2.0.  ScaleFactor = (int)Math.Floor(0x10000 * (double)(1 << ScaleShiftBits) / decimationFactor)
			ChannelFilterCoefficentRamSelect = 0x0080, // 0 = use ChannelFilterCoefficientRam0, 1 = use ChannelFilterCoefficientRam1
			MagnitudeTrigLevel = 0x0084, // This 31-bit unsigned register holds the magnitude trigger level used when the TriggerSource=Magnitude.  A trigger is generated whenever the magnitude of the IQ data  ( sqrt(I^2 + Q^2) ) crosses this level in either a positive going direction or a negative going direction, depending on the setting of the TriggerSlope.
			OverlapFactor = 0x008c, // If overlapFactor = 0, then only 1 IQ sample is skipped ahead on each FFT, which means 1023 out of 1024 IQ samples will be the same (99.9% overlap).  If overlapFactor = 255, then 256 IQ samples are skipped ahead on each FFT, which means 768 out of 1024 IQ samples will be the same (75% overlap).  If overlapFactor = 1023, then 1024 IQ samples are skipped ahead on each FFT, which means 0% overlap.
			FftSizeLog2 = 0x0090, // When processing frequency-domain data (i.e. the Fft is enabled), this register determines the log2 FFT size.  Valid range 3 to 11, which gives an 8 tap to 2048 tap FFT, respectively.  When doing time-domain processing, set this register to 0.
			DetectorDecimationFactor = 0x0094, // For frequency-domain data, this is the number of FFTs to combine in each detector frame.  Each FFT bin is effectively running its own set of detectors on just that FFT bin.  For time-domain data, this is the number of IQ samples to combine together per detector output.  Be sure to set FftSizeLog2 to 0 when detecting time-domain data.  Note that the Detector module expects log data going into it, which means that the ComplexMagnitude and Logger modules must be enabled whenever using the Detectors module.
			DetectorOffset = 0x0098, // Offset to apply in the Detector module to adjust the dB amplitude coming out of the detectors.  This register value is an 18-bit signed value where each LSB represents 0.0025 dB.
			ChannelPowerOffset = 0x00f0, // Offset to apply in the ChannelPower module to adjust the measured dB channel power.  This register value is a 16-bit unsigned value where each LSB represents 0.0025 dB.  Typically, the FFT window shape determines the value written to this register.
			ChannelPowerShapeRamBankSelect = 0x00f4, // There are 5 channel power shape RAMs used by the ChannelPower measurement.  This register determines which RAM bank is mapped to the address range 0xe000 to 0xffff.  This register also determines which of the 5 channel power measurement results is returned by ChannelPowerMeasurement.
			ChannelPowerMeasurement = 0x00f8, // Returns the channel power measurement result.  Full scale is 0 and each LSB represents -0.0025 dB.  The ChannelPowerShapeRamBankSelect selects which of the 5 channel power measurement results to return.
			PowerServoMinTargetPower = 0x0100, // Unsigned 16-bit log value where full scale is 0 and each LSB represents -0.0025 dB.  This value represents the minimum power level relative to full scale  that the PowerServo module will consider as the exit criteria to the power servo loop.
			PowerServoMaxTargetPower = 0x0104, // Unsigned 16-bit log value where full scale is 0 and each LSB represents -0.0025 dB.  This value represents the maximum power level relative to full scale  that the PowerServo module will consider as the exit criteria to the power servo loop.
			PowerServoMaxLoops = 0x0108, // Unsigned 8-bit value representing the maximum number of loops that the PowerServo will iterate through to try to achieve the target power before failing.
			PowerServoLoopCount = 0x010c, // Unsigned 8-bit value indicating the current loop count of the power servo.
			TraceConfig = 0x009c, // Configures the trace state and detectors for each of the 4 traces in the Trace module
			TraceAverageCount = 0x00a0, // Trace average count, which only applies when the trace state is set to RmsAverage
			IScaleFactor = 0x00a4, // IEEE 754 32-bit floating point number to scale the I Data (only applies when enableComplexScaleDouble == 1)
			QScaleFactor = 0x00a8, // IEEE 754 32-bit floating point number to scale the Q Data (only applies when enableComplexScaleDouble == 1)
			MeasControl = 0x00ac, // 
			BlockSize = 0x00b0, // Number of IQ samples per block to capture.  Always set BlockSize > 0.  If EnableAccumulate is true, then BlockSize must be set to a multiple of 4 between 32 and 8192.  If BlocksPerCapture > 1,  then BlockSize must be less than 2^16.
			BlocksPerCapture = 0x00b4, // Specifies the number of blocks to acquire in a measurement.  A measurement consists of the number of blocks specified by this register, each containing the number of IQ samples specified by the BlockSize register.  Each block requires a new trigger to initiate the capture for that block, except when the TriggerSource is FreeRun.  Always set BlocksPerCapture > 0.
			TriggerControl = 0x00b8, // Trigger configuration register
			TriggerDelay = 0x00bc, // This 32-bit signed value determines the number of IQ sample periods  between a trigger event and the actual collection of a block of data. Positive values delay data collection by the indicated number of samples. Negative values provide pre-trigger offsets. Negative values are valid only when BlocksPerCapture=1  and the EnablePreFftTrigger=0.
			TriggerHoldOff = 0x00c0, // This 32-bit unsigned register determines the Trigger Hold-Off in terms of IQ samples. If TriggerHoldOff is set to zero, it is equivalent to setting the Trigger Hold-Off Type to TriggerHoldOffType::None. Normal Trigger Hold-Off must be greater than or equal to 50 ns. The Trigger Hold-Off modes are specified by the TriggerControl register and documented above. This register only applies when BlocksPerCapture > 1 or when Continuous == 1.
			AutoTriggerTime = 0x00c4, // This register determines how much time (in number of IQ samples) elapses before a trigger is automatically generated.  If a trigger signal is not received before the specified auto trigger time, then the measurement state machine will automatically transition from the Trigger to Run state. Setting this register to 0 disables auto triggering. Setting this register > 0 will cause a counter to count that many IQ samples  (after decimation) before automatically generating the trigger.
			SampleIndexOfTriggerPosition = 0x00cc, // When a negative trigger delay is used, this read-only register returns the IQ sample index within capture memory where the trigger occurred.  Always set the WriteLength of the AdcDramWriter to a power of two when using a negative trigger delay.  Use the following equation to determine the sample index within capture memory where the trigger occurred: SampleIndexOfTriggerPosition % WriteLength
			RoundingSize = 0x00d0, // Rounds the I and Q data to fewer bits (which is a good idea to do if packing the data).  The most significant bits are kept and the least significant bits are zeroed-out.
			PackingSize = 0x00d4, // Determines how the IQ data is packed before sending it to capture RAM.
			Accumulate = 0x00d8, // Control for doing vector data block averaging in the fast capture RAM.  Block averaging can be either done in the time domain (when EnableFft is false) or in the frequency domain (when EnableFft is true).
			RathDebug0 = 0x00dc, // Experimental debugging register
			RathDebug1 = 0x00e0, // Experimental debugging register
			ChannelFilterCoefficientRam0 = 0x0800, // 128 Frequency-domain complex-valued filter taps (real in addresses ending in 0x0 or 0x8, imaginary in addresses ending in 0x4 or 0xc). Full Scale = 2^22
			ChannelFilterCoefficientRam1 = 0x0c00, // 128 Frequency-domain complex-valued filter taps (real in addresses ending in 0x0 or 0x8, imaginary in addresses ending in 0x4 or 0xc). Full Scale = 2^22
			CorrectionFilterCoefficientMemoryWindow = 0x1000, // Correction Filter Coefficient Memory Window span base address. Access location within CorrectionFilterCoefficientMemoryWindow span is specified by { CorrectionFilterControl.CtrlSetSelect, CorrectionFilterControl.CtrlMatrixElementSelect, s_axi_awaddr[log2FftLength:0] } because out of address space to map the entire Coefficient Memory. Each address accesses 18-bit 2's complement FFT coefficient with real components at even addresses and imaginary components at odd addresses. Must write real component first followed by imaginary component!
			FftWindowRam = 0x2000, // 2048 FFT window coefficients.  Each address is an 18-bit 2's complement coefficient representing the FFT window shape.
			PositivePeakDetectorRam = 0x4000, // Real-time positive peak detector.
			NegativePeakDetectorRam = 0x6000, // Real-time negative peak detector.
			SampleDetectorRam = 0x8000, // Real-time sample detector.
			NormalDetectorRam = 0xa000, // Real-time normal detector.
			RmsAverageDetectorRam = 0xc000, // Real-time RMS average detector.
			ChannelPowerShapeRam = 0xe000, // 2048 coefficients.  Each address is a 16-bit log value of the channel shape where the LSB represents -0.0025 dB.  A value of 0 represents unity gain, whereas 0xffff is effectively zero gain.  A -3.02 dB gain would be represented by the value 0x04b8.  There are 5 banks of the ChannelPowerShapeRam.  The bank is selected by the ChannelPowerShapeRamBankSelect register.
			FastCaptureRam = 0x10000, // Block average RAM made from block RAMs within the FPGA.
		}

		#endregion ReceiverRegisters Register enums

		#region ReceiverRegisters Register bitfield enums

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum EventBF
		{
			MeasDone,            // Bit   0 		 All Samples have been transferred into Capture Memory
			MeasOverflow,        // Bit   1 		 An IQ sample was captured that caused either an ADC over range or any other DSP math overflow.  An MeasOverflow will occur  whenever the measured ADC level is within 0.01 dB of the maximum or minimum ADC levels.  This event occurs whenever data is stored in capture memory that contains an IQ sample which overflowed.
			DetectorOverflow,    // Bit   2 		 An IQ sample was stored in detector RAM that caused either an ADC over range or any other DSP math overflow.  An DetectorOverflow will occur  whenever the measured ADC level is within 0.01 dB of the maximum or minimum ADC levels.  This event occurs whenever data is stored in detector RAM that contains an IQ sample which overflowed.
			EnteredIdleState,    // Bit   4 		 The measurement state machine entered the Idle state
			EnteredArmingState,  // Bit   5 		 The measurement state machine entered the Arming state
			EnteredTriggerState, // Bit   6 		 The measurement state machine entered the Trigger state
			EnteredRunState,     // Bit   7 		 The measurement state machine entered the Run state
			PreFftTriggerOccurred, // Bit   8 		 A trigger occurred in the PreFftTrigger module
			DetectorFrameReady,  // Bit   9 		 New detector traces are ready to be read out of detector RAM
			ChannelPowerReady,   // Bit  10 		 New channel power measurement results are ready
			PowerServoTargetPowerReached, // Bit  12 		 A '1' indicates that the PowerServo successfully achieved the target channel power, which is a power that is somewhere between PowerServoMinTargetPower and PowerServoMaxTargetPower.
			PowerServoSourceAtMinPower, // Bit  13 		 A '1' indicates the the PowerServo was unsuccessful because the source power level was adjusted all the way to the  minimum source power level (SourceDsp.PowerServoMinLogGain), but the target channel power was not achieved.
			PowerServoSourceAtMaxPower, // Bit  14 		 A '1' indicates the the PowerServo was unsuccessful because the source power level was adjusted all the way to the  maximum source power level (SourceDsp.PowerServoMaxLogGain), but the target channel power was not achieved.
			PowerServoReachedMaxLoopCount, // Bit  15 		 A '1' indicates the the PowerServo was unsuccessful because the maximum number of power servo loops (PowerServoMaxLoops) were iterated through without reaching the target channel power.
			DebugEvent,          // Bit  30 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CommandBF
		{
			StartStrobe,         // Bit   0 		 Starts the acquisition (moves state machine from the Idle state to Arming state)
			TriggerArmStrobe,    // Bit   1 		 Whenever TriggerArmStrobeRequired is set, writing to this bit is necessary to allow the measurement state machine to move from the Arming state to the Trigger state.
			SoftwareTriggerStrobe, // Bit   2 		 When the trigger source is Software, writing this bit generates the trigger.
			StopStrobe,          // Bit   3 		 Aborts any current acquisition and returns the measurement state machine to the Idle state
			ResetRegistersStrobe, // Bit   4 		 Changes all registers values back to their reset state.
			RestartTracesStrobe, // Bit   5 		 Restarts the min/max hold and trace averaging performed in the Traces FPGA module.
			SimDataStrobe,       // Bit   6 		 Sends the  SimIData, SimQData, and SimTrigger into the DSP path.   This is mainly meant for debugging and regression test purposes.  This strobe is only relevent when InputMux=SimulatedIqData.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ReceiverDspEnablesBF
		{
			EnableInputFifo,     // Bit   1 		 
			EnableSimulationMux, // Bit   2 		 
			EnableTriggerModule, // Bit   3 		 
			EnableGainAndOffset, // Bit   4 		 
			EnableWidebandMagnitudeTrigger, // Bit   5 		 
			EnableNcoAndMixer1,  // Bit   6 		 
			EnableDecimateBy4,   // Bit   7 		 
			EnableCorrectionFilter, // Bit   8 		 
			EnableNcoAndMixer2,  // Bit   9 		 
			EnableArbitraryDecimator, // Bit  10 		 
			EnableChannelFilter, // Bit  11 		 
			EnableMagnitudeTrigger, // Bit  12 		 
			EnablePreFftTrigger, // Bit  13 		 
			EnableOverlapMemory, // Bit  14 		 
			EnableFftWindow,     // Bit  15 		 
			EnableFft,           // Bit  16 		 
			EnableComplexMagnitude, // Bit  17 		 
			EnableLogger,        // Bit  18 		 
			EnableDetectors,     // Bit  19 		 
			EnableChannelPower,  // Bit  26 		 
			EnablePowerServo,    // Bit  27 		 
			EnableTraces,        // Bit  20 		 
			EnableComplexScaleDouble, // Bit  21 		 
			EnableMeasStateMachine, // Bit  22 		 
			EnableRounder,       // Bit  23 		 
			EnablePacker,        // Bit  24 		 
			EnableFastCaptureRam, // Bit  25 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum InputFifoConfigBF
		{
			UseLsbAsTrigger,     // Bit   2 		 0=Use all incoming data bits on both I and Q as data.  1=Use the least significant bit of the I data as a trigger mark.  This zeros out the least significant bit of both I and Q.  With InputPackedAs32Bits, bit 0 of I is used as the trigger mark, while bits 31 to 1 are used as the data. With InputPackedAs16Bits, bit 0 of I is used as the trigger mark while bits 15 to 1 are used as the data.  Bit 0 of Q is unused.
			NumSamplesPerClock,  // Bit   1 		 Determines the number of IQ samples output from the FIFO per 375 MHz clock period.   Data going into the FIFO is always 256 bits wide, which is either 4 IQ samples when InputPackingSize==InputPackedAs32Bits, or 8 IQ samples when InputPackingSize==InputPackedAs16Bits.  However, data coming out of the FIFO can only be 1 IQ sample per clock period, or 4 IQ samples per clock period.  Reverse flow control (using the adc_ready signal) is used to pause the incoming stream as necessary.  Reverse flow control only works when the ReceiverInputMux is set to the ADC DRAM Reader.  Reverse flow control is not possible when the ReceiverInputMux is set the JESD204B core from the AD9691 ADC.
			InputPackingSize,    // Bit   0 		 Determines if the input data going into the FIFO should be treated as 16-bit or 32-bit data.  Note that the FIFO always outputs 32 bits data.  When the input is packed as 16 bits, the 16-bit data will be put into the 16 most significant bits of the 32-bit output data, while the 16 least significant bits will be set to zeros.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum InputMuxBF
		{
			Value,               // Bits  0-31 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RampRateBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SimIDataBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SimQDataBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SimTriggerBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TriggerModuleControlBF
		{
			DelayValidUntilFirstTrigger, // Bit   1 		 Not currently used
			DelayArmingUntilHardwareReady, // Bit   0 		 Not currently used
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum AdcTriggerDelayBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum AdcDataDelayBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum IGainBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum QGainBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum IOffsetBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum QOffsetBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum WidebandMagnitudeTrigLevelBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum Nco1CoarsePhaseStepBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum Nco1FinePhaseStepBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum Nco1FinePhaseModulusBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CorrectionFilterControlBF
		{
			DspSetSelect,        // Bit  30 		 Zero-based index of the frequency domain coefficient set used by the DSP.
			CtrlWriteEnable,     // Bit  29 		 The control port write enable.
			CtrlSetSelect,       // Bit  27 		 Zero-based index of the frequency domain coefficient set to the control port. Also controls access location via CorrectionFilterCoefficientMemoryWindow span as { CtrlSetSelect, CtrlMatrixElementSelect, s_axi_awaddr[log2FftLength:0] }.
			CtrlMatrixElementSelect, // Bit  26 		 Selected generalized 2x2 Matrix element of frequency domain coefficient to the control port.  Also controls access location via CorrectionFilterCoefficientMemoryWindow span as { CtrlSetSelect, CtrlMatrixElementSelect, s_axi_awaddr[log2FftLength:0] }.
			CtrlReadBackModeEnabled, // Bit  13 		 Enables control port coefficient read back diagnostic override mode. Must be disabled for proper DSP operation!
			CtrlAddress,         // Bits  0-12 		 Zero-based index of frequency domain coefficient to the control port. Superfluous bits at positions greater than or equal to log2(FftLength) are ignored/truncated such that assignments at address FftLength and above alias to the range [0, FftLength).
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CorrectionFilterWriteReBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CorrectionFilterWriteImBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum Nco2CoarsePhaseStepBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum Nco2FinePhaseStepBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum Nco2FinePhaseModulusBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CoarseTimeStepBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum FineTimeStepBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum FineTimeModulusBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ScaleShiftBitsBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ScaleFactorBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelFilterCoefficentRamSelectBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum MagnitudeTrigLevelBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum OverlapFactorBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum FftSizeLog2BF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum DetectorDecimationFactorBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum DetectorOffsetBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelPowerOffsetBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelPowerShapeRamBankSelectBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelPowerMeasurementBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PowerServoMinTargetPowerBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PowerServoMaxTargetPowerBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PowerServoMaxLoopsBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PowerServoLoopCountBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TraceConfigBF
		{
			Trace3State,         // Bits 28-31 		 Determines the trace state for trace 2
			Trace3Detector,      // Bits 24-27 		 Determines the detector type for trace 2
			Trace2State,         // Bits 20-23 		 Determines the trace state for trace 2
			Trace2Detector,      // Bits 16-19 		 Determines the detector type for trace 2
			Trace1State,         // Bits 12-15 		 Determines the trace state for trace 1
			Trace1Detector,      // Bits  8-11 		 Determines the detector type for trace 1
			Trace0State,         // Bits  4- 7 		 Determines the trace state for trace 0
			Trace0Detector,      // Bits  0- 3 		 Determines the detector type for trace 0
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TraceAverageCountBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum IScaleFactorBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum QScaleFactorBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum MeasControlBF
		{
			TriggerArmStrobeRequired, // Bit   2 		 Set this bit to require an TriggerArmStrobe command before entering the Trigger state.  The state machine will stay in the Arm state until the TriggerArmStrobe command is received in addition to the usual requirements for transitioning into the Trigger state.
			ArmRequired,         // Bit   1 		 Setting  this bit to 1 will cause the measurement state machine to remain in the Arming state until all the digital filters have settled before going into the trigger state.
			Continuous,          // Bit   0 		 Setting this bit to 1 will cause the measurement state machine to remain in the run state continuously once it gets into the run state in the first place.  Only a StopStrobe  will get the state machine out of the run state.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum BlockSizeBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum BlocksPerCaptureBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TriggerControlBF
		{
			TriggerHoldOffType,  // Bits  4- 5 		 
			TriggerSource,       // Bits  0- 3 		 Determines the trigger source for the measurement state machine.
			TrigSlope,           // Bit   8 		 0 =  positive trigger slope, 1 = negative trigger slope. Only used when TriggerSource is External or Magnitude
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TriggerDelayBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum TriggerHoldOffBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum AutoTriggerTimeBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SampleIndexOfTriggerPositionBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RoundingSizeBF
		{
			Value,               // Bits  0-31 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PackingSizeBF
		{
			Value,               // Bits  0-31 		 
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum AccumulateBF
		{
			EnableAccumulate,    // Bit   0 		 When set, the blocks within a capture are vector accumulated into fast capture RAM.   Use the BlockSize register to determine the size of a block in fast capture RAM.  Since the fast capture RAM has a maximum depth of 8192 IQ samples, BlockSize should always be <= 8192 when using the fast capture RAM.  Also BlockSize must be set to a multiple of 4 for the accumulation to work correctly.  Use the BlocksPerCapture register to determine how many blocks to vector accumulate.  Vector accumulation only works correctly when PackingSize is set to PackAs32Bits.  When cleared, the blocks are concatenated into the fast capture RAM, making the capture output length equal to the BlockSize times the BlocksPerCapture.
			AccumulateShiftBits, // Bits 16-20 		 Range 0 to 16.  This register controls a barrel shifter on the data being accumulated in the fast capture RAM.  This is used to prevent fixed point math overflows by right shifting the data by this number of bits before accumulating the data.  Typically set this register to Log2 of the BlocksPerCapture.   For example, to accumulate 1024 vectors, set BlocksPerCapture to 1024 and set this register to 10.
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RathDebug0BF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RathDebug1BF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelFilterCoefficientRam0BF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelFilterCoefficientRam1BF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum CorrectionFilterCoefficientMemoryWindowBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum FftWindowRamBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum PositivePeakDetectorRamBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum NegativePeakDetectorRamBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum SampleDetectorRamBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum NormalDetectorRamBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum RmsAverageDetectorRamBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum ChannelPowerShapeRamBF
		{
			Value
		}

		[System.Reflection.Obfuscation( Exclude = true )]
		public enum FastCaptureRamBF
		{
			Value
		}

		#endregion ReceiverRegisters Register bitfield enums

		#region ReceiverRegisters Register bitfield values

		/// <summary>
		/// Values for the ReceiverDsp Register: InputFifoConfig, Bitfield: NumSamplesPerClock
		/// </summary>
		public enum NumSamplesPerClockValues
		{
			FourSamplesPerClock=0, // The FIFO will output 4 IQ samples per 375 MHz clock period.  Always use this setting when the ReceiverInputMux is set to output AD9689 ADC data from the JESD204B core.  Since most DSP blocks after the DecimateBy4 module can only handle 1 IQ sample per 312.5 MHz clock period, the DecimateBy4 module should be enabled whenever this setting is used.
			OneSamplePerClock=1, // The FIFO will output 1 IQ sample per 375 MHz clock period.
		}

		/// <summary>
		/// Values for the ReceiverDsp Register: InputFifoConfig, Bitfield: InputPackingSize
		/// </summary>
		public enum InputPackingSizeValues
		{
			InputPackedAs16Bits=0, // Treat input as 16-bit data (16-bit I and 16-bit Q).   Always use this setting when the ReceiverInputMux is set to output AD9691 ADC data from the JESD204B core.  The AD9691 ADC is actually a 14-bit ADC, but the data comes out packed as 16 bits where the ADC data is in the 14 most significant bits of the 16 bits.   Also, use this setting when the ReceiverInputMux is outputing data from the ADC DRAM Reader, and the RAM data is 16-bits wide  (16-bit I and 16-bit Q).
			InputPackedAs32Bits=1, // Treat input as 32-bit data (32-bit I and 32-bit Q).  Use this setting when the ReceiverInputMux is outputing data from the ADC Dram Reader, and the data is 32-bits wide  (32-bit I and 32-bit Q).  Note that the AD9691 ADC always outputs 16-bit data, so this setting doesn't make sense when the ReceiverInputMux is outputing data from the ADC JEDS204B core.
		}

		/// <summary>
		/// Values for the ReceiverDsp Register: InputMux, Bitfield: Value
		/// </summary>
		public enum InputMuxRegister
		{
			AdcData=0, // ADC Data from hardware
			SimulatedIqData=1, // Simulated I and Q Data from SimIData and SimQData registers
			RampData=2, // Counter data (0x00000000 to 0x00ffffff) sent to I, Constant 0xbeefcafe sent to Q
			NoData=15, // No Data
		}

		/// <summary>
		/// Values for the ReceiverDsp Register: CorrectionFilterControl, Bitfield: CtrlMatrixElementSelect
		/// </summary>
		public enum CtrlMatrixElementSelectValues
		{
			Normal = 0, 
			Invert = 1, 
		}

		/// <summary>
		/// Values for the ReceiverDsp Register: TraceConfig, Bitfield: Trace0State
		/// </summary>
		public enum Trace0StateValues
		{
			ClearWrite = 0, 
			MaxHold = 1, 
			MinHold = 2, 
			RmsAverage = 3, 
		}

		/// <summary>
		/// Values for the ReceiverDsp Register: TraceConfig, Bitfield: Trace0Detector
		/// </summary>
		public enum Trace0DetectorValues
		{
			Off = 0, 
			PositivePeakDetector = 1, 
			NegativePeakDetector = 2, 
			SampleDetector = 3, 
			NormalDetector = 4, 
			RmsAverageDetector = 5, 
		}

		/// <summary>
		/// Values for the ReceiverDsp Register: TriggerControl, Bitfield: TriggerHoldOffType
		/// </summary>
		public enum TriggerHoldOffTypeValues
		{
			None = 0, // Simple edge detection with no hold-off. This is the default and behaves as such when (TriggerHoldOff == 0).
			Normal = 1, // This is the “oscilloscope” type of trigger hold-off, and is the setting when the Hold-Off Type control does not appear. In this type of hold-off, no new trigger will be accepted until the hold-off interval has expired after the previous trigger.
			Above = 2, // If the trigger slope is positive, a trigger event is generated only if the signal characteristic of interest crosses the trigger threshold (with positive slope) and then remains above the threshold for at least the hold-off time. For negative slope, the trigger event is generated if the signal characteristic crosses the threshold (with negative slope) after having been above the threshold for at least the hold-off time. In either case, the trigger event is associated with the time the level was crossed.
			Below = 3, // If the trigger slope is positive, a trigger event is generated only if the signal characteristic of interest crosses the trigger threshold (with positive slope) after having been below the threshold for at least the hold-off time. For negative slope, the trigger event is generated if the signal characteristic crosses the threshold (with negative slope) and then remains below the threshold for at least the hold-off time. In either case, the trigger event is associated with the time the level was crossed.
		}

		/// <summary>
		/// Values for the ReceiverDsp Register: TriggerControl, Bitfield: TriggerSource
		/// </summary>
		public enum TriggerSourceValues
		{
			FreeRun=0, // The measurement state machine automatically and immediately goes from the Trigger state to the Run state.
			External=1, // The measurement state machine will stay in the Trigger state until an external trigger mark flows to the measurement state machine (or the AutoTriggerTime has elapsed).  The source of the external trigger mark is determined by ExternalTrigSelect.
			Software=2, // The measurement state machine will stay in the Trigger state until a 1 is written to the SoftwareTriggerStrobe bit in the Command register (or the AutoTriggerTime has elapsed).
			Magnitude=3, // A trigger will occur when the magnitude of the resampled and decimated IQ data crosses a specified threshold.  TrigSlope determines whether a positive or negative going threshold crossing causes the trigger.  MagnitudeTrigLevel sets the trigger level.
			WidebandMagnitude=4, // A trigger will occur when the magnitude of the input IQ data crosses a specified threshold.  TrigSlope determines whether a positive or negative going threshold crossing causes the trigger.  WidebandMagnitudeTrigLevel sets the trigger level.  The wideband magnitude trigger is meant to be a digital implementation of an RF burst trigger.
		}

		/// <summary>
		/// Values for the ReceiverDsp Register: RoundingSize, Bitfield: Value
		/// </summary>
		public enum RoundingSizeRegister
		{
			NoRounding=0, // Keep full 32-bit precision of I and Q
			RoundTo16Bits=1, // Round I and Q to 16-bits each
		}

		/// <summary>
		/// Values for the ReceiverDsp Register: PackingSize, Bitfield: Value
		/// </summary>
		public enum PackingSizeRegister
		{
			PackAs32Bits=0, // Pack data to 32-bits I and 32-bits Q
			PackAs16BitsMsb=1, // Pack data to 16-bits I and 16-bits Q, keeping the 16 most significant bits
			PackAs16BitsLsb=5, // Pack data to 16-bits I and 16-bits Q, keeping the 16 least significant bits
			PackAs16BitsMsbIOnly=3, // Pack data to 16-bits, keeping the 16 most significant bits.  Keep I Only.
			PackAs16BitsLsbIOnly=7, // Pack data to 16-bits, keeping the 16 least significant bits.  Keep I Only.
		}

		#endregion ReceiverRegisters Register bitfield values

		#region Member Variables

		private static readonly RegDef[] mRegisterDefinitions = new[]
			{
				new RegDef((int) ReceiverDspRegister.Event, 0x60000, typeof(EventBF), RegType.Event ),
				new RegDef((int) ReceiverDspRegister.InterruptMask, 0x60004, typeof(EventBF), RegType.RO ),
				new RegDef((int) ReceiverDspRegister.InterruptEvent, 0x60008, typeof(EventBF), RegType.RO ),
				new RegDef((int) ReceiverDspRegister.InterruptMaskSet, 0x60010, typeof(EventBF), RegType.Cmd |RegType.NoForce ),
				new RegDef((int) ReceiverDspRegister.InterruptMaskClear, 0x60014, typeof(EventBF), RegType.Cmd |RegType.NoForce ),
				new RegDef((int) ReceiverDspRegister.Command, 0x60018, typeof(CommandBF), RegType.Cmd |RegType.NoForce ),
				new RegDef((int) ReceiverDspRegister.ReceiverDspEnables, 0x6001c, typeof(ReceiverDspEnablesBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.InputFifoConfig, 0x600c8, typeof(InputFifoConfigBF), RegType.RW, 3 ),
				new RegDef((int) ReceiverDspRegister.InputMux, 0x60020, typeof(InputMuxBF), RegType.RW, 4 ),
				new RegDef((int) ReceiverDspRegister.RampRate, 0x60024, typeof(RampRateBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.SimIData, 0x60028, typeof(SimIDataBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.SimQData, 0x6002c, typeof(SimQDataBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.SimTrigger, 0x60030, typeof(SimTriggerBF), RegType.RW, 1 ),
				new RegDef((int) ReceiverDspRegister.TriggerModuleControl, 0x60034, typeof(TriggerModuleControlBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.AdcTriggerDelay, 0x60038, typeof(AdcTriggerDelayBF), RegType.RW, 15 ),
				new RegDef((int) ReceiverDspRegister.AdcDataDelay, 0x6003c, typeof(AdcDataDelayBF), RegType.RW, 12 ),
				new RegDef((int) ReceiverDspRegister.IGain, 0x60040, typeof(IGainBF), RegType.RW, 18 ),
				new RegDef((int) ReceiverDspRegister.QGain, 0x60044, typeof(QGainBF), RegType.RW, 18 ),
				new RegDef((int) ReceiverDspRegister.IOffset, 0x60048, typeof(IOffsetBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.QOffset, 0x6004c, typeof(QOffsetBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.WidebandMagnitudeTrigLevel, 0x60050, typeof(WidebandMagnitudeTrigLevelBF), RegType.RW, 31 ),
				new RegDef((int) ReceiverDspRegister.Nco1CoarsePhaseStep, 0x600e4, typeof(Nco1CoarsePhaseStepBF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.Nco1FinePhaseStep, 0x600e8, typeof(Nco1FinePhaseStepBF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.Nco1FinePhaseModulus, 0x600ec, typeof(Nco1FinePhaseModulusBF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.CorrectionFilterControl, 0x60054, typeof(CorrectionFilterControlBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.CorrectionFilterWriteRe, 0x60058, typeof(CorrectionFilterWriteReBF), RegType.RW, 18 ),
				new RegDef((int) ReceiverDspRegister.CorrectionFilterWriteIm, 0x6005c, typeof(CorrectionFilterWriteImBF), RegType.RW, 18 ),
				new RegDef((int) ReceiverDspRegister.Nco2CoarsePhaseStep, 0x60060, typeof(Nco2CoarsePhaseStepBF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.Nco2FinePhaseStep, 0x60064, typeof(Nco2FinePhaseStepBF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.Nco2FinePhaseModulus, 0x60068, typeof(Nco2FinePhaseModulusBF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.CoarseTimeStep, 0x6006c, typeof(CoarseTimeStepBF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.FineTimeStep, 0x60070, typeof(FineTimeStepBF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.FineTimeModulus, 0x60074, typeof(FineTimeModulusBF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.ScaleShiftBits, 0x60078, typeof(ScaleShiftBitsBF), RegType.RW, 5 ),
				new RegDef((int) ReceiverDspRegister.ScaleFactor, 0x6007c, typeof(ScaleFactorBF), RegType.RW, 17 ),
				new RegDef((int) ReceiverDspRegister.ChannelFilterCoefficentRamSelect, 0x60080, typeof(ChannelFilterCoefficentRamSelectBF), RegType.RW, 1 ),
				new RegDef((int) ReceiverDspRegister.MagnitudeTrigLevel, 0x60084, typeof(MagnitudeTrigLevelBF), RegType.RW, 31 ),
				new RegDef((int) ReceiverDspRegister.OverlapFactor, 0x6008c, typeof(OverlapFactorBF), RegType.RW, 11 ),
				new RegDef((int) ReceiverDspRegister.FftSizeLog2, 0x60090, typeof(FftSizeLog2BF), RegType.RW, 4 ),
				new RegDef((int) ReceiverDspRegister.DetectorDecimationFactor, 0x60094, typeof(DetectorDecimationFactorBF), RegType.RW, 16 ),
				new RegDef((int) ReceiverDspRegister.DetectorOffset, 0x60098, typeof(DetectorOffsetBF), RegType.RW, 18 ),
				new RegDef((int) ReceiverDspRegister.ChannelPowerOffset, 0x600f0, typeof(ChannelPowerOffsetBF), RegType.RW, 16 ),
				new RegDef((int) ReceiverDspRegister.ChannelPowerShapeRamBankSelect, 0x600f4, typeof(ChannelPowerShapeRamBankSelectBF), RegType.RW, 3 ),
				new RegDef((int) ReceiverDspRegister.ChannelPowerMeasurement, 0x600f8, typeof(ChannelPowerMeasurementBF), RegType.RO, 16 ),
				new RegDef((int) ReceiverDspRegister.PowerServoMinTargetPower, 0x60100, typeof(PowerServoMinTargetPowerBF), RegType.RW, 16 ),
				new RegDef((int) ReceiverDspRegister.PowerServoMaxTargetPower, 0x60104, typeof(PowerServoMaxTargetPowerBF), RegType.RW, 16 ),
				new RegDef((int) ReceiverDspRegister.PowerServoMaxLoops, 0x60108, typeof(PowerServoMaxLoopsBF), RegType.RW, 8 ),
				new RegDef((int) ReceiverDspRegister.PowerServoLoopCount, 0x6010c, typeof(PowerServoLoopCountBF), RegType.RO, 8 ),
				new RegDef((int) ReceiverDspRegister.TraceConfig, 0x6009c, typeof(TraceConfigBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.TraceAverageCount, 0x600a0, typeof(TraceAverageCountBF), RegType.RW, 16 ),
				new RegDef((int) ReceiverDspRegister.IScaleFactor, 0x600a4, typeof(IScaleFactorBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.QScaleFactor, 0x600a8, typeof(QScaleFactorBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.MeasControl, 0x600ac, typeof(MeasControlBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.BlockSize, 0x600b0, typeof(BlockSizeBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.BlocksPerCapture, 0x600b4, typeof(BlocksPerCaptureBF), RegType.RW, 16 ),
				new RegDef((int) ReceiverDspRegister.TriggerControl, 0x600b8, typeof(TriggerControlBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.TriggerDelay, 0x600bc, typeof(TriggerDelayBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.TriggerHoldOff, 0x600c0, typeof(TriggerHoldOffBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.AutoTriggerTime, 0x600c4, typeof(AutoTriggerTimeBF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.SampleIndexOfTriggerPosition, 0x600cc, typeof(SampleIndexOfTriggerPositionBF), RegType.RO ),
				new RegDef((int) ReceiverDspRegister.RoundingSize, 0x600d0, typeof(RoundingSizeBF), RegType.RW, 1 ),
				new RegDef((int) ReceiverDspRegister.PackingSize, 0x600d4, typeof(PackingSizeBF), RegType.RW, 3 ),
				new RegDef((int) ReceiverDspRegister.Accumulate, 0x600d8, typeof(AccumulateBF), RegType.RW, 14 ),
				new RegDef((int) ReceiverDspRegister.RathDebug0, 0x600dc, typeof(RathDebug0BF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.RathDebug1, 0x600e0, typeof(RathDebug1BF), RegType.RW ),
				new RegDef((int) ReceiverDspRegister.ChannelFilterCoefficientRam0, 0x60800, typeof(ChannelFilterCoefficientRam0BF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.ChannelFilterCoefficientRam1, 0x60c00, typeof(ChannelFilterCoefficientRam1BF), RegType.RW, 24 ),
				new RegDef((int) ReceiverDspRegister.CorrectionFilterCoefficientMemoryWindow, 0x61000, typeof(CorrectionFilterCoefficientMemoryWindowBF), RegType.RO, 18 ),
				new RegDef((int) ReceiverDspRegister.FftWindowRam, 0x62000, typeof(FftWindowRamBF), RegType.RW, 18 ),
				new RegDef((int) ReceiverDspRegister.PositivePeakDetectorRam, 0x64000, typeof(PositivePeakDetectorRamBF), RegType.RO, 17 ),
				new RegDef((int) ReceiverDspRegister.NegativePeakDetectorRam, 0x66000, typeof(NegativePeakDetectorRamBF), RegType.RO, 17 ),
				new RegDef((int) ReceiverDspRegister.SampleDetectorRam, 0x68000, typeof(SampleDetectorRamBF), RegType.RO, 17 ),
				new RegDef((int) ReceiverDspRegister.NormalDetectorRam, 0x6a000, typeof(NormalDetectorRamBF), RegType.RO, 17 ),
				new RegDef((int) ReceiverDspRegister.RmsAverageDetectorRam, 0x6c000, typeof(RmsAverageDetectorRamBF), RegType.RO, 18 ),
				new RegDef((int) ReceiverDspRegister.ChannelPowerShapeRam, 0x6e000, typeof(ChannelPowerShapeRamBF), RegType.RW, 16 ),
				new RegDef((int) ReceiverDspRegister.FastCaptureRam, 0x70000, typeof(FastCaptureRamBF), RegType.RO ),
			};

		private static readonly BitFieldDef[] mBitFieldDefinitions = new []
			{
				// NOTE: using 'typeof( EventBF )' will initialize the fields of all registers using that type
				new BitFieldDef( typeof( EventBF ), (int)EventBF.MeasDone, 0 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.MeasOverflow, 1 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.DetectorOverflow, 2 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.EnteredIdleState, 4 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.EnteredArmingState, 5 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.EnteredTriggerState, 6 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.EnteredRunState, 7 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.PreFftTriggerOccurred, 8 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.DetectorFrameReady, 9 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.ChannelPowerReady, 10 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.PowerServoTargetPowerReached, 12 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.PowerServoSourceAtMinPower, 13 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.PowerServoSourceAtMaxPower, 14 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.PowerServoReachedMaxLoopCount, 15 ),
				new BitFieldDef( typeof( EventBF ), (int)EventBF.DebugEvent, 30 ),
				// NOTE: using 'typeof( CommandBF )' will initialize the fields of all registers using that type
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.StartStrobe, 0 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.TriggerArmStrobe, 1 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.SoftwareTriggerStrobe, 2 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.StopStrobe, 3 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.ResetRegistersStrobe, 4 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.RestartTracesStrobe, 5 ),
				new BitFieldDef( typeof( CommandBF ), (int)CommandBF.SimDataStrobe, 6 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableInputFifo, 1 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableSimulationMux, 2 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableTriggerModule, 3 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableGainAndOffset, 4 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableWidebandMagnitudeTrigger, 5 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableNcoAndMixer1, 6 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableDecimateBy4, 7 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableCorrectionFilter, 8 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableNcoAndMixer2, 9 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableArbitraryDecimator, 10 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableChannelFilter, 11 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableMagnitudeTrigger, 12 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnablePreFftTrigger, 13 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableOverlapMemory, 14 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableFftWindow, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableFft, 16 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableComplexMagnitude, 17 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableLogger, 18 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableDetectors, 19 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableChannelPower, 26 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnablePowerServo, 27 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableTraces, 20 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableComplexScaleDouble, 21 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableMeasStateMachine, 22 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableRounder, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnablePacker, 24 ),
				new BitFieldDef( (int)ReceiverDspRegister.ReceiverDspEnables, (int)ReceiverDspEnablesBF.EnableFastCaptureRam, 25 ),
				new BitFieldDef( (int)ReceiverDspRegister.InputFifoConfig, (int)InputFifoConfigBF.UseLsbAsTrigger, 2 ),
				new BitFieldDef( (int)ReceiverDspRegister.InputFifoConfig, (int)InputFifoConfigBF.NumSamplesPerClock, 1 ),
				new BitFieldDef( (int)ReceiverDspRegister.InputFifoConfig, (int)InputFifoConfigBF.InputPackingSize, 0 ),
				new BitFieldDef( (int)ReceiverDspRegister.InputMux, (int)InputMuxBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.RampRate, (int)RampRateBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.SimIData, (int)SimIDataBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.SimQData, (int)SimQDataBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.SimTrigger, (int)SimTriggerBF.Value, 0, 0 ),
				new BitFieldDef( (int)ReceiverDspRegister.TriggerModuleControl, (int)TriggerModuleControlBF.DelayValidUntilFirstTrigger, 1 ),
				new BitFieldDef( (int)ReceiverDspRegister.TriggerModuleControl, (int)TriggerModuleControlBF.DelayArmingUntilHardwareReady, 0 ),
				new BitFieldDef( (int)ReceiverDspRegister.AdcTriggerDelay, (int)AdcTriggerDelayBF.Value, 0, 14 ),
				new BitFieldDef( (int)ReceiverDspRegister.AdcDataDelay, (int)AdcDataDelayBF.Value, 0, 11 ),
				new BitFieldDef( (int)ReceiverDspRegister.IGain, (int)IGainBF.Value, 0, 17 ),
				new BitFieldDef( (int)ReceiverDspRegister.QGain, (int)QGainBF.Value, 0, 17 ),
				new BitFieldDef( (int)ReceiverDspRegister.IOffset, (int)IOffsetBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.QOffset, (int)QOffsetBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.WidebandMagnitudeTrigLevel, (int)WidebandMagnitudeTrigLevelBF.Value, 0, 30 ),
				new BitFieldDef( (int)ReceiverDspRegister.Nco1CoarsePhaseStep, (int)Nco1CoarsePhaseStepBF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.Nco1FinePhaseStep, (int)Nco1FinePhaseStepBF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.Nco1FinePhaseModulus, (int)Nco1FinePhaseModulusBF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.DspSetSelect, 30 ),
				new BitFieldDef( (int)ReceiverDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlWriteEnable, 29 ),
				new BitFieldDef( (int)ReceiverDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlSetSelect, 27 ),
				new BitFieldDef( (int)ReceiverDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlMatrixElementSelect, 26 ),
				new BitFieldDef( (int)ReceiverDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlReadBackModeEnabled, 13 ),
				new BitFieldDef( (int)ReceiverDspRegister.CorrectionFilterControl, (int)CorrectionFilterControlBF.CtrlAddress, 0, 12 ),
				new BitFieldDef( (int)ReceiverDspRegister.CorrectionFilterWriteRe, (int)CorrectionFilterWriteReBF.Value, 0, 17 ),
				new BitFieldDef( (int)ReceiverDspRegister.CorrectionFilterWriteIm, (int)CorrectionFilterWriteImBF.Value, 0, 17 ),
				new BitFieldDef( (int)ReceiverDspRegister.Nco2CoarsePhaseStep, (int)Nco2CoarsePhaseStepBF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.Nco2FinePhaseStep, (int)Nco2FinePhaseStepBF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.Nco2FinePhaseModulus, (int)Nco2FinePhaseModulusBF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.CoarseTimeStep, (int)CoarseTimeStepBF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.FineTimeStep, (int)FineTimeStepBF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.FineTimeModulus, (int)FineTimeModulusBF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.ScaleShiftBits, (int)ScaleShiftBitsBF.Value, 0, 4 ),
				new BitFieldDef( (int)ReceiverDspRegister.ScaleFactor, (int)ScaleFactorBF.Value, 0, 16 ),
				new BitFieldDef( (int)ReceiverDspRegister.ChannelFilterCoefficentRamSelect, (int)ChannelFilterCoefficentRamSelectBF.Value, 0, 0 ),
				new BitFieldDef( (int)ReceiverDspRegister.MagnitudeTrigLevel, (int)MagnitudeTrigLevelBF.Value, 0, 30 ),
				new BitFieldDef( (int)ReceiverDspRegister.OverlapFactor, (int)OverlapFactorBF.Value, 0, 10 ),
				new BitFieldDef( (int)ReceiverDspRegister.FftSizeLog2, (int)FftSizeLog2BF.Value, 0, 3 ),
				new BitFieldDef( (int)ReceiverDspRegister.DetectorDecimationFactor, (int)DetectorDecimationFactorBF.Value, 0, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.DetectorOffset, (int)DetectorOffsetBF.Value, 0, 17 ),
				new BitFieldDef( (int)ReceiverDspRegister.ChannelPowerOffset, (int)ChannelPowerOffsetBF.Value, 0, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.ChannelPowerShapeRamBankSelect, (int)ChannelPowerShapeRamBankSelectBF.Value, 0, 2 ),
				new BitFieldDef( (int)ReceiverDspRegister.ChannelPowerMeasurement, (int)ChannelPowerMeasurementBF.Value, 0, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.PowerServoMinTargetPower, (int)PowerServoMinTargetPowerBF.Value, 0, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.PowerServoMaxTargetPower, (int)PowerServoMaxTargetPowerBF.Value, 0, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.PowerServoMaxLoops, (int)PowerServoMaxLoopsBF.Value, 0, 7 ),
				new BitFieldDef( (int)ReceiverDspRegister.PowerServoLoopCount, (int)PowerServoLoopCountBF.Value, 0, 7 ),
				new BitFieldDef( (int)ReceiverDspRegister.TraceConfig, (int)TraceConfigBF.Trace3State, 28, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.TraceConfig, (int)TraceConfigBF.Trace3Detector, 24, 27 ),
				new BitFieldDef( (int)ReceiverDspRegister.TraceConfig, (int)TraceConfigBF.Trace2State, 20, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.TraceConfig, (int)TraceConfigBF.Trace2Detector, 16, 19 ),
				new BitFieldDef( (int)ReceiverDspRegister.TraceConfig, (int)TraceConfigBF.Trace1State, 12, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.TraceConfig, (int)TraceConfigBF.Trace1Detector, 8, 11 ),
				new BitFieldDef( (int)ReceiverDspRegister.TraceConfig, (int)TraceConfigBF.Trace0State, 4, 7 ),
				new BitFieldDef( (int)ReceiverDspRegister.TraceConfig, (int)TraceConfigBF.Trace0Detector, 0, 3 ),
				new BitFieldDef( (int)ReceiverDspRegister.TraceAverageCount, (int)TraceAverageCountBF.Value, 0, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.IScaleFactor, (int)IScaleFactorBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.QScaleFactor, (int)QScaleFactorBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.MeasControl, (int)MeasControlBF.TriggerArmStrobeRequired, 2 ),
				new BitFieldDef( (int)ReceiverDspRegister.MeasControl, (int)MeasControlBF.ArmRequired, 1 ),
				new BitFieldDef( (int)ReceiverDspRegister.MeasControl, (int)MeasControlBF.Continuous, 0 ),
				new BitFieldDef( (int)ReceiverDspRegister.BlockSize, (int)BlockSizeBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.BlocksPerCapture, (int)BlocksPerCaptureBF.Value, 0, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.TriggerControl, (int)TriggerControlBF.TriggerHoldOffType, 4, 5 ),
				new BitFieldDef( (int)ReceiverDspRegister.TriggerControl, (int)TriggerControlBF.TriggerSource, 0, 3 ),
				new BitFieldDef( (int)ReceiverDspRegister.TriggerControl, (int)TriggerControlBF.TrigSlope, 8 ),
				new BitFieldDef( (int)ReceiverDspRegister.TriggerDelay, (int)TriggerDelayBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.TriggerHoldOff, (int)TriggerHoldOffBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.AutoTriggerTime, (int)AutoTriggerTimeBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.SampleIndexOfTriggerPosition, (int)SampleIndexOfTriggerPositionBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.RoundingSize, (int)RoundingSizeBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.PackingSize, (int)PackingSizeBF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.Accumulate, (int)AccumulateBF.EnableAccumulate, 0 ),
				new BitFieldDef( (int)ReceiverDspRegister.Accumulate, (int)AccumulateBF.AccumulateShiftBits, 16, 20 ),
				new BitFieldDef( (int)ReceiverDspRegister.RathDebug0, (int)RathDebug0BF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.RathDebug1, (int)RathDebug1BF.Value, 0, 31 ),
				new BitFieldDef( (int)ReceiverDspRegister.ChannelFilterCoefficientRam0, (int)ChannelFilterCoefficientRam0BF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.ChannelFilterCoefficientRam1, (int)ChannelFilterCoefficientRam1BF.Value, 0, 23 ),
				new BitFieldDef( (int)ReceiverDspRegister.CorrectionFilterCoefficientMemoryWindow, (int)CorrectionFilterCoefficientMemoryWindowBF.Value, 0, 17 ),
				new BitFieldDef( (int)ReceiverDspRegister.FftWindowRam, (int)FftWindowRamBF.Value, 0, 17 ),
				new BitFieldDef( (int)ReceiverDspRegister.PositivePeakDetectorRam, (int)PositivePeakDetectorRamBF.Value, 0, 16 ),
				new BitFieldDef( (int)ReceiverDspRegister.NegativePeakDetectorRam, (int)NegativePeakDetectorRamBF.Value, 0, 16 ),
				new BitFieldDef( (int)ReceiverDspRegister.SampleDetectorRam, (int)SampleDetectorRamBF.Value, 0, 16 ),
				new BitFieldDef( (int)ReceiverDspRegister.NormalDetectorRam, (int)NormalDetectorRamBF.Value, 0, 16 ),
				new BitFieldDef( (int)ReceiverDspRegister.RmsAverageDetectorRam, (int)RmsAverageDetectorRamBF.Value, 0, 17 ),
				new BitFieldDef( (int)ReceiverDspRegister.ChannelPowerShapeRam, (int)ChannelPowerShapeRamBF.Value, 0, 15 ),
				new BitFieldDef( (int)ReceiverDspRegister.FastCaptureRam, (int)FastCaptureRamBF.Value, 0, 31 ),
			};

		#endregion Member Variables

		#region Register Accessors
		public Reg32T<EventBF> Event
		{
			get;
			private set;
		}
		public Reg32T<EventBF> InterruptMask
		{
			get;
			private set;
		}
		public Reg32T<EventBF> InterruptEvent
		{
			get;
			private set;
		}
		public Reg32T<EventBF> InterruptMaskSet
		{
			get;
			private set;
		}
		public Reg32T<EventBF> InterruptMaskClear
		{
			get;
			private set;
		}
		public Reg32T<CommandBF> Command
		{
			get;
			private set;
		}
		public Reg32T<ReceiverDspEnablesBF> ReceiverDspEnables
		{
			get;
			private set;
		}
		public Reg32T<InputFifoConfigBF> InputFifoConfig
		{
			get;
			private set;
		}
		public Reg32T<InputMuxBF> InputMux
		{
			get;
			private set;
		}
		public Reg32T<RampRateBF> RampRate
		{
			get;
			private set;
		}
		public Reg32T<SimIDataBF> SimIData
		{
			get;
			private set;
		}
		public Reg32T<SimQDataBF> SimQData
		{
			get;
			private set;
		}
		public Reg32T<SimTriggerBF> SimTrigger
		{
			get;
			private set;
		}
		public Reg32T<TriggerModuleControlBF> TriggerModuleControl
		{
			get;
			private set;
		}
		public Reg32T<AdcTriggerDelayBF> AdcTriggerDelay
		{
			get;
			private set;
		}
		public Reg32T<AdcDataDelayBF> AdcDataDelay
		{
			get;
			private set;
		}
		public Reg32T<IGainBF> IGain
		{
			get;
			private set;
		}
		public Reg32T<QGainBF> QGain
		{
			get;
			private set;
		}
		public Reg32T<IOffsetBF> IOffset
		{
			get;
			private set;
		}
		public Reg32T<QOffsetBF> QOffset
		{
			get;
			private set;
		}
		public Reg32T<WidebandMagnitudeTrigLevelBF> WidebandMagnitudeTrigLevel
		{
			get;
			private set;
		}
		public Reg32T<Nco1CoarsePhaseStepBF> Nco1CoarsePhaseStep
		{
			get;
			private set;
		}
		public Reg32T<Nco1FinePhaseStepBF> Nco1FinePhaseStep
		{
			get;
			private set;
		}
		public Reg32T<Nco1FinePhaseModulusBF> Nco1FinePhaseModulus
		{
			get;
			private set;
		}
		public Reg32T<CorrectionFilterControlBF> CorrectionFilterControl
		{
			get;
			private set;
		}
		public Reg32T<CorrectionFilterWriteReBF> CorrectionFilterWriteRe
		{
			get;
			private set;
		}
		public Reg32T<CorrectionFilterWriteImBF> CorrectionFilterWriteIm
		{
			get;
			private set;
		}
		public Reg32T<Nco2CoarsePhaseStepBF> Nco2CoarsePhaseStep
		{
			get;
			private set;
		}
		public Reg32T<Nco2FinePhaseStepBF> Nco2FinePhaseStep
		{
			get;
			private set;
		}
		public Reg32T<Nco2FinePhaseModulusBF> Nco2FinePhaseModulus
		{
			get;
			private set;
		}
		public Reg32T<CoarseTimeStepBF> CoarseTimeStep
		{
			get;
			private set;
		}
		public Reg32T<FineTimeStepBF> FineTimeStep
		{
			get;
			private set;
		}
		public Reg32T<FineTimeModulusBF> FineTimeModulus
		{
			get;
			private set;
		}
		public Reg32T<ScaleShiftBitsBF> ScaleShiftBits
		{
			get;
			private set;
		}
		public Reg32T<ScaleFactorBF> ScaleFactor
		{
			get;
			private set;
		}
		public Reg32T<ChannelFilterCoefficentRamSelectBF> ChannelFilterCoefficentRamSelect
		{
			get;
			private set;
		}
		public Reg32T<MagnitudeTrigLevelBF> MagnitudeTrigLevel
		{
			get;
			private set;
		}
		public Reg32T<OverlapFactorBF> OverlapFactor
		{
			get;
			private set;
		}
		public Reg32T<FftSizeLog2BF> FftSizeLog2
		{
			get;
			private set;
		}
		public Reg32T<DetectorDecimationFactorBF> DetectorDecimationFactor
		{
			get;
			private set;
		}
		public Reg32T<DetectorOffsetBF> DetectorOffset
		{
			get;
			private set;
		}
		public Reg32T<ChannelPowerOffsetBF> ChannelPowerOffset
		{
			get;
			private set;
		}
		public Reg32T<ChannelPowerShapeRamBankSelectBF> ChannelPowerShapeRamBankSelect
		{
			get;
			private set;
		}
		public Reg32T<ChannelPowerMeasurementBF> ChannelPowerMeasurement
		{
			get;
			private set;
		}
		public Reg32T<PowerServoMinTargetPowerBF> PowerServoMinTargetPower
		{
			get;
			private set;
		}
		public Reg32T<PowerServoMaxTargetPowerBF> PowerServoMaxTargetPower
		{
			get;
			private set;
		}
		public Reg32T<PowerServoMaxLoopsBF> PowerServoMaxLoops
		{
			get;
			private set;
		}
		public Reg32T<PowerServoLoopCountBF> PowerServoLoopCount
		{
			get;
			private set;
		}
		public Reg32T<TraceConfigBF> TraceConfig
		{
			get;
			private set;
		}
		public Reg32T<TraceAverageCountBF> TraceAverageCount
		{
			get;
			private set;
		}
		public Reg32T<IScaleFactorBF> IScaleFactor
		{
			get;
			private set;
		}
		public Reg32T<QScaleFactorBF> QScaleFactor
		{
			get;
			private set;
		}
		public Reg32T<MeasControlBF> MeasControl
		{
			get;
			private set;
		}
		public Reg32T<BlockSizeBF> BlockSize
		{
			get;
			private set;
		}
		public Reg32T<BlocksPerCaptureBF> BlocksPerCapture
		{
			get;
			private set;
		}
		public Reg32T<TriggerControlBF> TriggerControl
		{
			get;
			private set;
		}
		public Reg32T<TriggerDelayBF> TriggerDelay
		{
			get;
			private set;
		}
		public Reg32T<TriggerHoldOffBF> TriggerHoldOff
		{
			get;
			private set;
		}
		public Reg32T<AutoTriggerTimeBF> AutoTriggerTime
		{
			get;
			private set;
		}
		public Reg32T<SampleIndexOfTriggerPositionBF> SampleIndexOfTriggerPosition
		{
			get;
			private set;
		}
		public Reg32T<RoundingSizeBF> RoundingSize
		{
			get;
			private set;
		}
		public Reg32T<PackingSizeBF> PackingSize
		{
			get;
			private set;
		}
		public Reg32T<AccumulateBF> Accumulate
		{
			get;
			private set;
		}
		public Reg32T<RathDebug0BF> RathDebug0
		{
			get;
			private set;
		}
		public Reg32T<RathDebug1BF> RathDebug1
		{
			get;
			private set;
		}
		public Reg32T<ChannelFilterCoefficientRam0BF> ChannelFilterCoefficientRam0
		{
			get;
			private set;
		}
		public Reg32T<ChannelFilterCoefficientRam1BF> ChannelFilterCoefficientRam1
		{
			get;
			private set;
		}
		public Reg32T<CorrectionFilterCoefficientMemoryWindowBF> CorrectionFilterCoefficientMemoryWindow
		{
			get;
			private set;
		}
		public Reg32T<FftWindowRamBF> FftWindowRam
		{
			get;
			private set;
		}
		public Reg32T<PositivePeakDetectorRamBF> PositivePeakDetectorRam
		{
			get;
			private set;
		}
		public Reg32T<NegativePeakDetectorRamBF> NegativePeakDetectorRam
		{
			get;
			private set;
		}
		public Reg32T<SampleDetectorRamBF> SampleDetectorRam
		{
			get;
			private set;
		}
		public Reg32T<NormalDetectorRamBF> NormalDetectorRam
		{
			get;
			private set;
		}
		public Reg32T<RmsAverageDetectorRamBF> RmsAverageDetectorRam
		{
			get;
			private set;
		}
		public Reg32T<ChannelPowerShapeRamBF> ChannelPowerShapeRam
		{
			get;
			private set;
		}
		public Reg32T<FastCaptureRamBF> FastCaptureRam
		{
			get;
			private set;
		}
		#endregion Register Accessors

		/// <summary>
		/// Creates the device register set (typed registers). Uses the 'default' BAR
		/// (which is normally specified in the register spreadsheet).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		public ReceiverDspRegisterSet( IRegManager manager, IInstrument module, string groupName )
			: this( manager, module, groupName, (int)BaseAddress.ReceiverDsp0, /*barIndex=*/0 )
		{
		}
		/// <summary>
		/// Creates the device register set (typed registers). Uses the 'default' BAR
		/// (which is normally specified in the register spreadsheet).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		/// <param name="registerSetOffset">an offset added to all register offsets</param>
		public ReceiverDspRegisterSet( IRegManager manager, IInstrument module, string groupName, int registerSetOffset )
			: this( manager, module, groupName, registerSetOffset, /*barIndex=*/0 )
		{
		}
		/// <summary>
		/// Creates the device register set (typed registers).
		/// Note that the BAR and offset can be specified by the caller so the same RegisterSet
		/// class can be used to define multiple unique RegisterSet instances (different offset
		/// and or BAR).
		/// </summary>
		/// <param name="manager">the IRegManager instance to add this RegisterSet to</param>
		/// <param name="instrument">the IInstrument instance these registers are for</param>
		/// <param name="groupName">the group name used to access this RegisterSet from IRegManager</param>
		/// <param name="registerSetOffset">an offset added to all register offsets</param>
		/// <param name="barIndex">the BAR to use</param>
		public ReceiverDspRegisterSet( IRegManager manager, IInstrument module, string groupName, int registerSetOffset, int barIndex )
		{
			// Create the factory
			RegFactory regFactory = new RegFactory( registerSetOffset, module, Reg32.ConstructReg );

			// Determine which IRegDriver (determines default BAR)
			IRegDriver regDriver = ( barIndex >= module.RegDrivers.Length ) ? null : module.RegDrivers[ barIndex ];
			if( regDriver == null )
			{
				throw new InternalApplicationException( "ReceiverDspRegisterSet requires RegDriver for BAR" + barIndex );
			}

			// Create the register definitions 
			Registers = regFactory.CreateRegArray(
				mRegisterDefinitions,
				typeof( ReceiverDspRegister ),
				regDriver,
				module.Name );

			regFactory.CreateBitFields( mBitFieldDefinitions, Registers, module.Name, string.Empty );

			if( manager != null )
			{
				// Adding as a group creates an IDirtyBit and attaches to each register
				manager.AddGroup( groupName, this );
			}
			Event = new Reg32T<EventBF>((Reg32)Registers[(Int32)ReceiverDspRegister.Event]);
			InterruptMask = new Reg32T<EventBF>((Reg32)Registers[(Int32)ReceiverDspRegister.InterruptMask]);
			InterruptEvent = new Reg32T<EventBF>((Reg32)Registers[(Int32)ReceiverDspRegister.InterruptEvent]);
			InterruptMaskSet = new Reg32T<EventBF>((Reg32)Registers[(Int32)ReceiverDspRegister.InterruptMaskSet]);
			InterruptMaskClear = new Reg32T<EventBF>((Reg32)Registers[(Int32)ReceiverDspRegister.InterruptMaskClear]);
			Command = new Reg32T<CommandBF>((Reg32)Registers[(Int32)ReceiverDspRegister.Command]);
			ReceiverDspEnables = new Reg32T<ReceiverDspEnablesBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ReceiverDspEnables ]);
			InputFifoConfig = new Reg32T<InputFifoConfigBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.InputFifoConfig ]);
			InputMux = new Reg32T<InputMuxBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.InputMux ]);
			RampRate = new Reg32T<RampRateBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.RampRate ]);
			SimIData = new Reg32T<SimIDataBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.SimIData ]);
			SimQData = new Reg32T<SimQDataBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.SimQData ]);
			SimTrigger = new Reg32T<SimTriggerBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.SimTrigger ]);
			TriggerModuleControl = new Reg32T<TriggerModuleControlBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.TriggerModuleControl ]);
			AdcTriggerDelay = new Reg32T<AdcTriggerDelayBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.AdcTriggerDelay ]);
			AdcDataDelay = new Reg32T<AdcDataDelayBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.AdcDataDelay ]);
			IGain = new Reg32T<IGainBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.IGain ]);
			QGain = new Reg32T<QGainBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.QGain ]);
			IOffset = new Reg32T<IOffsetBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.IOffset ]);
			QOffset = new Reg32T<QOffsetBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.QOffset ]);
			WidebandMagnitudeTrigLevel = new Reg32T<WidebandMagnitudeTrigLevelBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.WidebandMagnitudeTrigLevel ]);
			Nco1CoarsePhaseStep = new Reg32T<Nco1CoarsePhaseStepBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.Nco1CoarsePhaseStep ]);
			Nco1FinePhaseStep = new Reg32T<Nco1FinePhaseStepBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.Nco1FinePhaseStep ]);
			Nco1FinePhaseModulus = new Reg32T<Nco1FinePhaseModulusBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.Nco1FinePhaseModulus ]);
			CorrectionFilterControl = new Reg32T<CorrectionFilterControlBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.CorrectionFilterControl ]);
			CorrectionFilterWriteRe = new Reg32T<CorrectionFilterWriteReBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.CorrectionFilterWriteRe ]);
			CorrectionFilterWriteIm = new Reg32T<CorrectionFilterWriteImBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.CorrectionFilterWriteIm ]);
			Nco2CoarsePhaseStep = new Reg32T<Nco2CoarsePhaseStepBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.Nco2CoarsePhaseStep ]);
			Nco2FinePhaseStep = new Reg32T<Nco2FinePhaseStepBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.Nco2FinePhaseStep ]);
			Nco2FinePhaseModulus = new Reg32T<Nco2FinePhaseModulusBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.Nco2FinePhaseModulus ]);
			CoarseTimeStep = new Reg32T<CoarseTimeStepBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.CoarseTimeStep ]);
			FineTimeStep = new Reg32T<FineTimeStepBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.FineTimeStep ]);
			FineTimeModulus = new Reg32T<FineTimeModulusBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.FineTimeModulus ]);
			ScaleShiftBits = new Reg32T<ScaleShiftBitsBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ScaleShiftBits ]);
			ScaleFactor = new Reg32T<ScaleFactorBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ScaleFactor ]);
			ChannelFilterCoefficentRamSelect = new Reg32T<ChannelFilterCoefficentRamSelectBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ChannelFilterCoefficentRamSelect ]);
			MagnitudeTrigLevel = new Reg32T<MagnitudeTrigLevelBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.MagnitudeTrigLevel ]);
			OverlapFactor = new Reg32T<OverlapFactorBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.OverlapFactor ]);
			FftSizeLog2 = new Reg32T<FftSizeLog2BF>((Reg32)Registers[ (Int32)ReceiverDspRegister.FftSizeLog2 ]);
			DetectorDecimationFactor = new Reg32T<DetectorDecimationFactorBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.DetectorDecimationFactor ]);
			DetectorOffset = new Reg32T<DetectorOffsetBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.DetectorOffset ]);
			ChannelPowerOffset = new Reg32T<ChannelPowerOffsetBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ChannelPowerOffset ]);
			ChannelPowerShapeRamBankSelect = new Reg32T<ChannelPowerShapeRamBankSelectBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ChannelPowerShapeRamBankSelect ]);
			ChannelPowerMeasurement = new Reg32T<ChannelPowerMeasurementBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ChannelPowerMeasurement ]);
			PowerServoMinTargetPower = new Reg32T<PowerServoMinTargetPowerBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.PowerServoMinTargetPower ]);
			PowerServoMaxTargetPower = new Reg32T<PowerServoMaxTargetPowerBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.PowerServoMaxTargetPower ]);
			PowerServoMaxLoops = new Reg32T<PowerServoMaxLoopsBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.PowerServoMaxLoops ]);
			PowerServoLoopCount = new Reg32T<PowerServoLoopCountBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.PowerServoLoopCount ]);
			TraceConfig = new Reg32T<TraceConfigBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.TraceConfig ]);
			TraceAverageCount = new Reg32T<TraceAverageCountBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.TraceAverageCount ]);
			IScaleFactor = new Reg32T<IScaleFactorBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.IScaleFactor ]);
			QScaleFactor = new Reg32T<QScaleFactorBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.QScaleFactor ]);
			MeasControl = new Reg32T<MeasControlBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.MeasControl ]);
			BlockSize = new Reg32T<BlockSizeBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.BlockSize ]);
			BlocksPerCapture = new Reg32T<BlocksPerCaptureBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.BlocksPerCapture ]);
			TriggerControl = new Reg32T<TriggerControlBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.TriggerControl ]);
			TriggerDelay = new Reg32T<TriggerDelayBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.TriggerDelay ]);
			TriggerHoldOff = new Reg32T<TriggerHoldOffBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.TriggerHoldOff ]);
			AutoTriggerTime = new Reg32T<AutoTriggerTimeBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.AutoTriggerTime ]);
			SampleIndexOfTriggerPosition = new Reg32T<SampleIndexOfTriggerPositionBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.SampleIndexOfTriggerPosition ]);
			RoundingSize = new Reg32T<RoundingSizeBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.RoundingSize ]);
			PackingSize = new Reg32T<PackingSizeBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.PackingSize ]);
			Accumulate = new Reg32T<AccumulateBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.Accumulate ]);
			RathDebug0 = new Reg32T<RathDebug0BF>((Reg32)Registers[ (Int32)ReceiverDspRegister.RathDebug0 ]);
			RathDebug1 = new Reg32T<RathDebug1BF>((Reg32)Registers[ (Int32)ReceiverDspRegister.RathDebug1 ]);
			ChannelFilterCoefficientRam0 = new Reg32T<ChannelFilterCoefficientRam0BF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ChannelFilterCoefficientRam0 ]);
			ChannelFilterCoefficientRam1 = new Reg32T<ChannelFilterCoefficientRam1BF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ChannelFilterCoefficientRam1 ]);
			CorrectionFilterCoefficientMemoryWindow = new Reg32T<CorrectionFilterCoefficientMemoryWindowBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.CorrectionFilterCoefficientMemoryWindow ]);
			FftWindowRam = new Reg32T<FftWindowRamBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.FftWindowRam ]);
			PositivePeakDetectorRam = new Reg32T<PositivePeakDetectorRamBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.PositivePeakDetectorRam ]);
			NegativePeakDetectorRam = new Reg32T<NegativePeakDetectorRamBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.NegativePeakDetectorRam ]);
			SampleDetectorRam = new Reg32T<SampleDetectorRamBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.SampleDetectorRam ]);
			NormalDetectorRam = new Reg32T<NormalDetectorRamBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.NormalDetectorRam ]);
			RmsAverageDetectorRam = new Reg32T<RmsAverageDetectorRamBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.RmsAverageDetectorRam ]);
			ChannelPowerShapeRam = new Reg32T<ChannelPowerShapeRamBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.ChannelPowerShapeRam ]);
			FastCaptureRam = new Reg32T<FastCaptureRamBF>((Reg32)Registers[ (Int32)ReceiverDspRegister.FastCaptureRam ]);
		}

		/// <summary>
		/// Sets the initial values for the registers. Does not apply the values (write to HW).
		/// </summary>
		public override void SetInitialValues()
		{
			Event.Field( EventBF.MeasDone ).Value = 0;
			Event.Field( EventBF.MeasOverflow ).Value = 0;
			Event.Field( EventBF.DetectorOverflow ).Value = 0;
			Event.Field( EventBF.EnteredIdleState ).Value = 0;
			Event.Field( EventBF.EnteredArmingState ).Value = 0;
			Event.Field( EventBF.EnteredTriggerState ).Value = 0;
			Event.Field( EventBF.EnteredRunState ).Value = 0;
			Event.Field( EventBF.PreFftTriggerOccurred ).Value = 0;
			Event.Field( EventBF.DetectorFrameReady ).Value = 0;
			Event.Field( EventBF.ChannelPowerReady ).Value = 0;
			Event.Field( EventBF.PowerServoTargetPowerReached ).Value = 0;
			Event.Field( EventBF.PowerServoSourceAtMinPower ).Value = 0;
			Event.Field( EventBF.PowerServoSourceAtMaxPower ).Value = 0;
			Event.Field( EventBF.PowerServoReachedMaxLoopCount ).Value = 0;
			Event.Field( EventBF.DebugEvent ).Value = 0;
			InterruptMaskSet.Value = 0;
			InterruptMaskClear.Value = 0;
			Command.Field( CommandBF.StartStrobe ).Value = 0;
			Command.Field( CommandBF.TriggerArmStrobe ).Value = 0;
			Command.Field( CommandBF.SoftwareTriggerStrobe ).Value = 0;
			Command.Field( CommandBF.StopStrobe ).Value = 0;
			Command.Field( CommandBF.ResetRegistersStrobe ).Value = 0;
			Command.Field( CommandBF.RestartTracesStrobe ).Value = 0;
			Command.Field( CommandBF.SimDataStrobe ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableInputFifo ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableSimulationMux ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableTriggerModule ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableGainAndOffset ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableWidebandMagnitudeTrigger ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableNcoAndMixer1 ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableDecimateBy4 ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableCorrectionFilter ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableNcoAndMixer2 ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableArbitraryDecimator ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableChannelFilter ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableMagnitudeTrigger ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnablePreFftTrigger ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableOverlapMemory ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableFftWindow ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableFft ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableComplexMagnitude ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableLogger ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableDetectors ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableChannelPower ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnablePowerServo ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableTraces ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableComplexScaleDouble ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableMeasStateMachine ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableRounder ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnablePacker ).Value = 0;
			ReceiverDspEnables.Field( ReceiverDspEnablesBF.EnableFastCaptureRam ).Value = 0;
			InputFifoConfig.Field( InputFifoConfigBF.UseLsbAsTrigger ).Value = 0;
			InputFifoConfig.Field( InputFifoConfigBF.NumSamplesPerClock ).Value = 0;
			InputFifoConfig.Field( InputFifoConfigBF.InputPackingSize ).Value = 0;
			InputMux.Field( InputMuxBF.Value ).Value = 0;
			RampRate.Value = 1431655764;
			SimIData.Value = 0;
			SimQData.Value = 0;
			SimTrigger.Value = 0;
			TriggerModuleControl.Field( TriggerModuleControlBF.DelayValidUntilFirstTrigger ).Value = 0;
			TriggerModuleControl.Field( TriggerModuleControlBF.DelayArmingUntilHardwareReady ).Value = 0;
			AdcTriggerDelay.Value = 0;
			AdcDataDelay.Value = 0;
			IGain.Value = 65536;
			QGain.Value = 65536;
			IOffset.Value = 0;
			QOffset.Value = 0;
			WidebandMagnitudeTrigLevel.Value = 0;
			Nco1CoarsePhaseStep.Value = 0;
			Nco1FinePhaseStep.Value = 0;
			Nco1FinePhaseModulus.Value = -5058467;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.DspSetSelect ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlWriteEnable ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlSetSelect ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlMatrixElementSelect ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlReadBackModeEnabled ).Value = 0;
			CorrectionFilterControl.Field( CorrectionFilterControlBF.CtrlAddress ).Value = 0;
			CorrectionFilterWriteRe.Value = 0;
			CorrectionFilterWriteIm.Value = 0;
			Nco2CoarsePhaseStep.Value = 0;
			Nco2FinePhaseStep.Value = 0;
			Nco2FinePhaseModulus.Value = -5058467;
			CoarseTimeStep.Value = 0;
			FineTimeStep.Value = 0;
			FineTimeModulus.Value = -5058467;
			ScaleShiftBits.Value = 0;
			ScaleFactor.Value = 65536;
			ChannelFilterCoefficentRamSelect.Value = 0;
			MagnitudeTrigLevel.Value = 0;
			OverlapFactor.Value = 0;
			FftSizeLog2.Value = 0;
			DetectorDecimationFactor.Value = 1;
			DetectorOffset.Value = 0;
			ChannelPowerOffset.Value = 0;
			ChannelPowerShapeRamBankSelect.Value = 0;
			PowerServoMinTargetPower.Value = 0;
			PowerServoMaxTargetPower.Value = 0;
			PowerServoMaxLoops.Value = 0;
			TraceConfig.Field( TraceConfigBF.Trace3State ).Value = 0;
			TraceConfig.Field( TraceConfigBF.Trace3Detector ).Value = 0;
			TraceConfig.Field( TraceConfigBF.Trace2State ).Value = 0;
			TraceConfig.Field( TraceConfigBF.Trace2Detector ).Value = 0;
			TraceConfig.Field( TraceConfigBF.Trace1State ).Value = 0;
			TraceConfig.Field( TraceConfigBF.Trace1Detector ).Value = 0;
			TraceConfig.Field( TraceConfigBF.Trace0State ).Value = 0;
			TraceConfig.Field( TraceConfigBF.Trace0Detector ).Value = 0;
			TraceAverageCount.Value = 0;
			IScaleFactor.Value = 1065353216;
			QScaleFactor.Value = 1065353216;
			MeasControl.Field( MeasControlBF.TriggerArmStrobeRequired ).Value = 0;
			MeasControl.Field( MeasControlBF.ArmRequired ).Value = 0;
			MeasControl.Field( MeasControlBF.Continuous ).Value = 0;
			BlockSize.Value = 1;
			BlocksPerCapture.Value = 1;
			TriggerControl.Field( TriggerControlBF.TriggerHoldOffType ).Value = 0;
			TriggerControl.Field( TriggerControlBF.TriggerSource ).Value = 0;
			TriggerControl.Field( TriggerControlBF.TrigSlope ).Value = 0;
			TriggerDelay.Value = 0;
			TriggerHoldOff.Value = 0;
			AutoTriggerTime.Value = 0;
			RoundingSize.Field( RoundingSizeBF.Value ).Value = 0;
			PackingSize.Field( PackingSizeBF.Value ).Value = 0;
			Accumulate.Field( AccumulateBF.EnableAccumulate ).Value = 0;
			Accumulate.Field( AccumulateBF.AccumulateShiftBits ).Value = 0;
			RathDebug0.Value = 0;
			RathDebug1.Value = 0;
			ChannelFilterCoefficientRam0.Value = 0;
			ChannelFilterCoefficientRam1.Value = 0;
			FftWindowRam.Value = 0;
			ChannelPowerShapeRam.Value = 0;
		}
	}

	#endregion RegisterSets
}
